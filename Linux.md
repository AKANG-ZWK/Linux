

# Linux

## Lesson 1 常见指令 && 权限

### ls 指令 - (list)

> **语法**： ls [选项] [目录或文件]
> **功能**：对于目录，该指令列出该目录下的所有子目录与文件。对于文件，将列出文件名以及其他信息。
> **常用选项**：
> -a 列出目录下的所有文件，包括以 . 开头的隐含文件。
> -d 将目录象文件一样显示，而不是显示其下的文件。 如： ls –d 指定目录
> -i 输出文件的 i 节点的索引信息。 如 ls –ai 指定文件
> -k 以 k 字节的形式表示文件的大小。 ls –alk 指定文件
> -l 列出文件的详细信息。
> -n 用数字的 UID,GID 代替名称。 （介绍 UID， GID）
> -F 在每个文件名后附上一个字符以说明该文件的类型， “*”表示可执行的普通文件； “/”表示目录； “@”表
> 示符号链接； “|”表示FIFOs； “=”表示套接字(sockets)。（目录类型识别）
> -r 对目录反向排序。
> -t 以时间排序。
> -s 在l文件名后输出该文件的大小。（大小排序，如何找到目录下最大的文件）
> -R 列出所有子目录下的文件。 (递归)
> -1 一行只输出一个文件。  



> 在linux中，“ll”命令指的是“ls -l”命令，它是“ls -l”命令的一个别名，用于以长格式显示目录下的内容列表；输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等。



==指令使用举例==

- `ls -l -a -d AKANG`

<img src=".\Image\image-20220917093424875.png" alt="image-20220917093424875" style="zoom:50%;" />



指令本质上也是一个程序->文件->windows上的exe

![image-20220917095417533](.\Image\image-20220917095417533.png)



- `which ls ` 查看ls指令的路径

- `alias`相当于起别名

![image-20220917095018823](.\Image\image-20220917095018823.png)

​		可以自己给指令起别名，例如：

![image-20220917101217602](.\Image\image-20220917101217602.png)



注意：自定义的指令只能在本次会话中使用，退出再登录后将不起作用。

### pwd指令 - (print working directory)

> 显示当前所在目录



==为什么我们能够可以“采用路径”的方式进行定位文件？==



因为采用多叉树的文件目录，每一个文件都相当于一个结点，每个结点都只有一个父结点，因此从根结点到每一个叶节点的路径都具有唯一性。此时说的路径是**绝对路径**。



`/home/AKANG` 是绝对路径  而 `../../`指的是上级目录的上级目录，是**相对路径**。因为当前处于`/home/AKANG`，上级目录的上级目录是根目录。

![image-20220917145416770](.\Image\image-20220917145416770.png)

==执行一个文件的方式==

1. 采用相对路径的方法

   **`. `是当前目录  `..` 是上级目录**



![image-20220917150429944](.\Image\image-20220917150429944.png)

2. 采用绝对路径的方法

![image-20220917150941342](.\Image\image-20220917150941342.png)



**一般来说，绿色的文件是可执行文件，蓝色是目录**



### cd指令 - （change directory）

Linux系统中，磁盘上的文件和目录被组成一棵目录树，每个节点都是目录或文件。  

> **语法**:cd 目录名
> **功能**：改变工作目录。将当前工作目录改变到指定的目录下。
> **举例**：  
>
> cd ..  : 返回上级目录
> cd /home/litao/linux/  : 绝对路径
> cd ../day02/  : 相对路径
> cd ~ ：进入用户家目录      ~ 表示的是当前用户的工作目录
> cd -  ：返回最近访问目录   - 记录我最近从哪里来的路径



root用户对应的工作目录是 `/root`   普通用户的工作目录是 `/home/XXX`

### touch指令

> **语法**:touch [选项]... 文件...
> **功能**：touch指令参数可更改文档或目录的日期时间，包括存取时间和更改时间，或者新建一个不存在的文件。
> **常用选项**：  
>
> -a 或--time=atime或--time=access或--time=use只更改存取时间。
> -c 或--no-create 不建立任何文档。
> -d 使用指定的日期时间，而非现在的时间。
> -f 此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。
> -m 或--time=mtime或--time=modify 只更改变动时间。
> -r 把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同。
> -t 使用指定的日期时间，而非现在的时间  



touch只创建普通的文本文件，创建目录有专门的方式。



==举例==



更新文件的最新修改时间（默认是所有时间）

<img src=".\Image\image-20220917184333946.png" alt="image-20220917184333946" style="zoom: 80%;" />

`stat`指令

<img src=".\Image\image-20220917190851616.png" alt="image-20220917190851616" style="zoom: 67%;" />



> - **Access\Modify\Change的初始时间记录都是文件被创建的时间**
> - **Access** 指最后一次读取的时间（访问）
> - **Modify** 指最后一次修改数据的时间（修改）
> - **Change** 指最后一次修改元数据的时间（改变）

### mkdir指令

> **语法**： mkdir [选项] dirname...
> **功能**：在当前目录下创建一个名为 “dirname”的目录
> **常用选项**：
>
> -p, --parents 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录  



==举例==

<img src=".\Image\image-20220917192605594.png" alt="image-20220917192605594" style="zoom: 67%;" />



**总结**： mkdir 默认可以创建一个空目录，加上-p选项可以创建一条路径

### rm指令&&rmdir指令 （remove）

> rmdir是一个与mkdir相对应的命令。 mkdir是建立目录，而rmdir是删除命令。
>
> **语法**： rmdir [-p] [dirName]
> **适用对象**：具有当前目录操作权限的所有使用者
> **功能**：删除空目录
> **常用选项**：
> -p 当子目录被删除后如果父目录也变成空目录的话，就连带父目录一起删除。



==举例==



`rmdir mydir`

<img src=".\Image\image-20220917201358773.png" alt="image-20220917201358773" style="zoom: 67%;" />



> rm命令可以同时删除文件或目录
>  **语法**： rm [-f-i-r-v] [dirName/dir]
> **适用对象**：所有使用者
> **功能**：删除文件或目录  
>
> **常用选项**：
> -f 即使文件属性为只读(即写保护)，亦直接删除 （强制删除，不询问，大部分文件都可以删除）
> -i 删除前逐一询问确认
> -r 删除目录及其下所有文件  
>
> 也可以组合-rf 递归强制删除 （很严重的操作）



==举例==



-  `rm -r p1` 递归删除目录，目录p1里面还有p2，p2里面还有p3


<img src=".\Image\image-20220917201620501.png" alt="image-20220917201620501" style="zoom:67%;" />

-  批量删除对应后缀的文件 `find . -name ".c" | xargs rm`

<img src=".\Image\image-20221013171921539.png" alt="image-20221013171921539" style="zoom: 67%;" />

### man指令

> Linux的命令有很多参数，我们不可能全记住，我们可以通过查看联机手册获取帮助。访问Linux手册页的命令是
> **man 语法**: man [选项] 命令
> **常用选项**：
> -k 根据关键字搜索联机帮助
> num 只在第num章节找
> -a 将所有章节的都显示出来，比如 man printf 它缺省从第一章开始搜索，知道就停止，用a选项，当按下q退出，他会继续往后面搜索，直到所有章节都搜索完毕。
>
> 
>
> 解释一下,man手册分为8章
> 1 是普通的命令
> 2 是系统调用,如open,write之类的(通过这个，至少可以很方便的查到调用这个函数，需要加什么头文件)
> 3 是库函数,如printf,fread4是特殊文件,也就是/dev下的各种设备文件
> 5 是指文件的格式,比如passwd, 就会说明这个文件中各个字段的含义
> 6 是给游戏留的,由各个游戏自己定义
> 7 是附件还有一些变量,比如向environ这种全局变量在这里就有说明
> 8 是系统管理用的命令,这些命令只能由root使用,如ifconfig  



==举例==



`man 3 printf` 在第3章中查找printf的手册

### cp指令 - （copy）

> **语法**： cp [选项] 源文件或目录 目标文件或目录
> **功能**: 复制文件或目录
> **说明**: cp指令用于复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到此目录中。若同时指定多个文件或目录，而最后的目的地并非一个已存在的目录，则会出现错误信息
>  **常用选项**：
> -f 或 --force 强行复制文件或目录， 不论目的文件或目录是否已经存在
> -i 或 --interactive 覆盖文件之前先询问用户
> -r递归处理，将指定目录下的文件与子目录一并处理。若源文件或目录的形态，不属于目录或符号链
> 接，则一律视为普通文件处理
> -R 或 --recursive递归处理，将指定目录下的文件及子目录一并处理  



==举例==



1. `cp test.txt ../Test` 拷贝mydir目录中的test.txt文件到上级目录下的Test目录中

<img src=".\Image\image-20220917214006595.png" alt="image-20220917214006595" style="zoom:67%;" />

2. `cp -rf mydir mydir_backip` 拷贝目录mydir，以mydir_backup存储。 `-rf`是递归强制复制

<img src=".\Image\image-20220917214557150.png" alt="image-20220917214557150" style="zoom:67%;" />



### mv指令 - (move)

> mv命令是move的缩写，可以用来移动文件或者将文件改名（move (rename) files），是Linux系统下常用的命令，经常用来备份文件或者目录。
>
> 
>
> **语法**: mv [选项] 源文件或目录 目标文件或目录
> **功能**:
>
> 1. 视mv命令中第二个参数类型的不同（是目标文件还是目标目录）， mv命令将文件重命名或将其移至一个新的目录中。
>
> 2. 当第二个参数类型是文件时， mv命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。
> 3. 当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个， mv命令将各参数指定的源文件均移至目标目录中。
>
> **常用选项**：
> -f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖
> -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖  



==举例==

1. 在mydir目录中创建move.txt文件，然后剪切到mydir_backup中

<img src=".\Image\image-20220917221242793.png" alt="image-20220917221242793" style="zoom:67%;" />



**总结**：1.mv能实现类似剪切的功能  2.mv能实现重命名



### cat指令

> **语法**： cat [选项] [文件]
> **功能**： 查看目标文件的内容
> **常用选项**：
> -b 对非空输出行编号
> -n 对输出的所有行编号
> -s 不输出多行空  



tac是逆序输出文本

cat不加文件名，默认从键盘输入内容

### more指令 - （不推荐使用）

> 语法： more [选项] [文件]
> 功能： more命令，功能类似 cat
> 常用选项：
> 
> q 退出more  



more只能按回车向下看文本



==举例==



`-5`表示输出5行，按回车往下继续翻，输入`/100`会输出100附近的数字



<img src=".\Image\image-20220917224839313.png" alt="image-20220917224839313" style="zoom:80%;" />



### less指令 - （比more好用）

- less 工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极其强大。
- less 的用法比起 more 更加的有弹性。在 more 的时候，我们并没有办法向前面翻， 只能往后面看但若使用了 less 时，就可以使用 [pageup] [pagedown] 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！
- 除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜  

> **语法**： less [参数] 文件
> **功能**：less与more类似，但使用less可以随意浏览文件，而more仅能向前移动，却不能向后移动，而且less在查看之前不会加载整个文件。
> **选项**：
> -i 忽略搜索时的大小写
> -N 显示每行的行号
> /字符串：向下搜索“字符串”的功能
> ?字符串：向上搜索“字符串”的功能
> n：重复前一个搜索（与 / 或 ? 有关）
> N：反向重复前一个搜索（与 / 或 ? 有关）
> q:quit  



==more和less存在的意义==



如果我们要查看大文件，例如日志、代码，打开不方便，此时就要用到这两个指令来查看我们想要的信息。

### head指令

head 与 tail 就像它的名字一样的浅显易懂，它是用来显示开头或结尾某个数量的文字区块， head 用来显示档案的开头至标准输出中，而 tail 想当然尔就是看档案的结尾  

> **语法**： head [参数]... [文件]...
> **功能**：
> head 用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。
> **选项**：  
>
> -n 显示n行

### tail指令

tail 命令从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不但刷新,使你看到最新的文件内容 。

> **语法**： tail[必要参数] [选择参数] [文件]
> **功能**： 用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。
> **选项**：  
>
> -f 循环读取
> -n<行数> 显示行数  

### echo

- `echo "hello world > log.txt" `: echo后面加字符串，则字符串内容会被输出的屏幕

- `echo "hello world > log.txt"` : 输出重定向，如果对应文件不存在，则创建该文件，并将字符串存在里面，再次执行输出重定向则会清空原始文件内容重新写入。

  <img src=".\Image\image-20220918195806270.png" alt="image-20220918195806270" style="zoom: 67%;" />

-   `echo "hello" >> log.txt` : 追加重定向，不会覆盖原来的内容，而是换行再追加

  <img src=".\Image\image-20220918200051866.png" alt="image-20220918200051866" style="zoom: 67%;" />

- `cat < log.txt` : 输出重定向

- `head -120 file.txt | tail -20` ： 输出文件中的100-120行的内容. `|`叫做==**管道**==，将前面指令的执行结果留在其中，供下一条指令使用

  <img src=".\Image\image-20220918202537809.png" alt="image-20220918202537809" style="zoom:50%;" />

### 时间相关指令

1. ==**date显示**==
   date 指定格式显示时间： date +%Y:%m:%d
   date 用法： date [OPTION]... [+FORMAT]
    1.在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记，其中常用的标记列表如下 
   %H : 小时(00..23)
   %M : 分钟(00..59)
   %S : 秒(00..61)
   %X : 相当于 %H:%M:%S
   %d : 日 (01..31)
   %m : 月份 (01..12)
   %Y : 完整年份 (0000..9999)
   %F : 相当于 %Y-%m-%d

   ![image-20220918210237379](.\Image\image-20220918210237379.png)

   ![image-20220918210448302](.\Image\image-20220918210448302.png)

2. ==**在设定时间方面**==
   date -s //设置当前时间，只有root权限才能设置，其他只能查看。
   date -s 20080523 //设置成20080523，这样会把具体时间设置成空00:00:00
   date -s 01:01:01 //设置具体时间，不会对日期做更改
   date -s “01:01:01 2008-05-23″ //这样可以设置全部时间
   date -s “01:01:01 20080523″ //这样可以设置全部时间
   date -s “2008-05-23 01:01:01″ //这样可以设置全部时间
   date -s “20080523 01:01:01″ //这样可以设置全部时间

3. ==**时间戳**==
   时间->时间戳： date +%s
   时间戳->时间： date -d@1508749502
   Unix时间戳（英文为Unix epoch, Unix time, POSIX time 或 Unix timestamp）是从1970年1月1日（UTC/GMT的午夜）开始所经过的秒数，不考虑闰秒  

### cal指令 - （calendar）

> cal命令可以用来显示公历（阳历）日历。公历是现在国际通用的历法，又称格列历，通称阳历。 “阳历”又名“太阳历”，系以地球绕行太阳一周为一年，为西方各国所通用，故又名“西历”。  



> **命令格式**： cal [参数] [月份] [年份]
> **功能**： 用于查看日历等时间信息，如只有一个参数，则表示年份(1-9999)，如有两个参数，则表示月份和年份
> **常用选项**：
> -3 显示系统前一个月，当前月，下一个月的月历
> -j 显示在当年中的第几天（一年日期按天算，从1月1号算起，默认显示当前月在一年中的天数）
> -y 显示当前年份的日历



**举例：**  

<img src=".\Image\image-20220925101536516.png" alt="image-20220925101536516" style="zoom:50%;" />

### find指令 - 非常重要

- Linux下find命令在目录结构中搜索文件，并执行指定的操作。
- Linux下find命令提供了相当多的查找条件，功能很强大。由于find具有强大的功能，所以它的选项也很多，其中大部分选项都值得我们花时间来了解一下。
- 即使系统中含有网络文件系统( NFS)， find命令在该文件系统中同样有效，只你具有相应的权限。
- 在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系统可能会花费很长的时间(这里是指30G字节以上的文件系统)。  

> 语法： find pathname -options
> 功能： 用于在文件树种查找文件，并作出相应的处理（可能访问磁盘）
> 常用选项：
> -name 按照文件名查找文件 



- 查找后缀名为`.c`的文件并删除 ` find . -name "*.c"`

<img src=".\Image\image-20221013171554122.png" alt="image-20221013171554122" style="zoom:50%;" />

### grep指令

> grep全称是**Global Regular Expression Print**，表示全局正则表达式版本，它的使用权限是所有用户。
>
> 
>
> **语法**： grep [选项] 搜寻字符串 文件
> **功能**： 在文件中搜索字符串，将找到的行打印出来
> **常用选项**：
> -i ：忽略大小写的不同，所以大小写视为相同
> -n ：顺便输出行号
> -v ：反向选择，亦即显示出没有 '搜寻字符串' 内容的那一行  

> **[options]主要参数：**
>
> －c：只输出匹配行的计数。
> －I：不区分大 小写(只适用于单字符)。
> －h：查询多文件时不显示文件名。
> －l：查询多文件时只输出包含匹配字符的文件名。
> －n：显示匹配行及 行号。
> －s：不显示不存在或无匹配文本的错误信息。
> －v：显示不包含匹配文本的所有行。
>
> 
>
> **pattern正则表达式主要参数：**
> \： 忽略正则表达式中特殊字符的原有含义。
> ^：匹配正则表达式的开始行。
> $: 匹配正则表达式的结束行。
> \<：从匹配正则表达 式的行开始。
> \>：到匹配正则表达式的行结束。
> [ ]：单个字符，如[A]即A符合要求 。
> [ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。
> 。：所有的单个字符。





**举例**：

- 输出file.txt中带99的行

  `cat file.txt | grep '99'`

<img src=".\Image\image-20220925103955728.png" alt="image-20220925103955728" style="zoom:50%;" />

或者`grep '99' file.txt`

<img src=".\Image\image-20220925104402874.png" alt="image-20220925104402874" style="zoom:50%;" />

- `-i`选项

<img src=".\Image\image-20220925135634445.png" alt="image-20220925135634445" style="zoom:50%;" />

- 正则表达式

<img src=".\Image\image-20220925140835268.png" alt="image-20220925140835268" style="zoom:50%;" />

- `grep -E ^a try_grep.txt` 在try_grep.txt文件中寻找a开头的单词

<img src=".\Image\image-20221013170129763.png" alt="image-20221013170129763" style="zoom: 50%;" />

### 查看网络进程的命令

`netstat -tanlp`

### 查看进程的指令

`ps axj | grep 9093`

<img src=".\Image\image-20230302111559361.png" alt="image-20230302111559361" style="zoom: 67%;" />



`ps axj | grep XXX`

`ps axj | head -1 && ps axj | grep mythread`

### zip/unzip指令

> **语法**： zip 压缩文件.zip 目录或文件
> **功能**： 将目录或文件压缩成zip格式
> **常用选项**：
> -r 递归处理，将指定目录下的所有文件和子目录一并处理
>
> -d 选项配合unzip可以指明解压路径



**举例**：
将test2目录压缩： zip test2.zip test2/*
解压到tmp目录： unzip test2.zip -d /tmp  



**在Test目录中创建lesson1目录，lesson1目录中包括三个文件，将lesson1文件压缩，取名lesson.zip，然后将lesson.zip剪切到test目录中，在test目录中解压lesson.zip**

```
[AKANG@VM-8-9-centos ~]$ cd Test
[AKANG@VM-8-9-centos Test]$ ls
lesson1
[AKANG@VM-8-9-centos Test]$ tree lesson1
lesson1
|-- file1.txt
|-- file2.txt
`-- file3.txt

0 directories, 3 files
[AKANG@VM-8-9-centos Test]$ zip lesson1

zip error: Nothing to do! (lesson1.zip)
[AKANG@VM-8-9-centos Test]$ zip -r lesson.zip lesson1/
  adding: lesson1/ (stored 0%)
  adding: lesson1/file2.txt (stored 0%)
  adding: lesson1/file1.txt (stored 0%)
  adding: lesson1/file3.txt (stored 0%)
[AKANG@VM-8-9-centos Test]$ ls
lesson1  lesson.zip
[AKANG@VM-8-9-centos Test]$ mkdir test
[AKANG@VM-8-9-centos Test]$ ls
lesson1  lesson.zip  test
[AKANG@VM-8-9-centos Test]$ mv lesson.zip test
[AKANG@VM-8-9-centos Test]$ cd test
[AKANG@VM-8-9-centos test]$ unzip lesson.zip
Archive:  lesson.zip
   creating: lesson1/
 extracting: lesson1/file2.txt       
 extracting: lesson1/file1.txt       
 extracting: lesson1/file3.txt       
[AKANG@VM-8-9-centos test]$ tree lesson
lesson [error opening dir]

0 directories, 0 files
[AKANG@VM-8-9-centos test]$ tree lesson1
lesson1
|-- file1.txt
|-- file2.txt
`-- file3.txt

0 directories, 3 files
```

### tar指令（重要）

打包/解包，不打开它，直接看内容  

> tar [-cxtzjvf] 文件与目录 .... 
>
> **参数**：  
> -c ：建立一个压缩文件的参数指令(create 的意思)；
> -x ：解开一个压缩文件的参数指令！
> -t ：查看 tarfile 里面的文件！
> -z ：是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩？
> -j ：是否同时具有 bzip2 的属性？亦即是否需要用 bzip2 压缩？
> -v ：压缩的过程中显示文件！这个常用，但不建议用在背景执行过程！
> -f ：使用档名，请留意，在 f 之后要立即接档名喔！不要再加参数！
> -C ： 解压到指定目录  



```
范例一：将整个 /etc 目录下的文件全部打包成为 `/tmp/etc.tar`
[root@linux ~]# tar -cvf /tmp/etc.tar /etc<==仅打包，不压缩！
[root@linux ~]# tar -zcvf /tmp/etc.tar.gz /etc <==打包后，以 gzip 压缩
[root@linux ~]# tar -jcvf /tmp/etc.tar.bz2 /etc <==打包后，以 bzip2 压缩
特别注意，在参数 f 之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。
如果加 z 参数，则以 .tar.gz 或 .tgz 来代表 gzip 压缩过的 tar file ～
如果加 j 参数，则以 .tar.bz2 来作为附档名啊～
上述指令在执行的时候，会显示一个警告讯息：
『`tar: Removing leading `/" from member names`』那是关於绝对路径的特殊设定
```

### bc指令

> Linux下的计算器，可以进行浮点型运算
>
> **bc进入，quit退出**



**举例**

- 通过管道计算字符表达式的结果`echo "1+2+3+4" | bc`

<img src=".\Image\image-20220925150645735.png" alt="image-20220925150645735" style="zoom:50%;" />

### uname –r指令

> **语法**： uname [选项]
> **功能**： uname用来获取电脑和操作系统的相关信息。
> **补充说明**： uname可显示linux主机所用的操作系统的版本、硬件的名称等基本信息。
> **常用选项**：  
> -a或–all 详细输出所有信息，依次为内核名称，主机名，内核版本号，内核版本，硬件名，处理器类型，硬件平台类型，操作系统名称  

举例

![image-20220925151308419](.\Image\image-20220925151308419.png)



### netstat

**netstat是一个用来查看网络状态的重要工具.**
语法： netstat [选项]
功能：查看网络状态
常用选项：
				n 拒绝显示别名，能显示数字的全部转化成数字
				l 仅列出有在 Listen (监听) 的服務状态
				p 显示建立相关链接的程序名
				t (tcp)仅显示tcp相关选项
				u (udp)仅显示udp相关选项
				a (all)显示所有选项，默认不显示LISTEN相关

**查看网络进程的命令**

`netstat -tanlp`

### pidof

**在查看服务器的进程id时非常方便.**
语法： pidof [进程名]
功能：通过进程名, 查看进程id  

### wc代码行数统计

> 功能：查询文件的大小数据
>
> 使用方式：wc [选项] 文件 ...
>
> 参数选项：
>
> -c 统计字节数。
>
> -l 统计行数。
>
> -m [统计字符](https://so.csdn.net/so/search?q=统计字符&spm=1001.2101.3001.7020)数。这个标志不能与 -c 标志一起使用。
>
> -w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。
>
> -L 打印最长行的长度。
>
> -help 显示帮助信息并退出
>
> --version 显示版本信息并退出

example： wc -l ./*.hpp  查询当前文件夹中所有hpp后缀文件的代码行数

### 经常使用的快捷键

**tab按两下**    ： 指令补全

**control + c**  ： 终止一切异常命令

**control + d**  ： 按一下推出登录，按两下退出xshell

**control + r**   ： 根据历史命令补全

**history**        ： 显示历史命令

**file**              ： 显示文件的信息

**shutdown**  ： 关机  云服务器永远不关机！！！



### 扩展命令

◆ 安装和登录命令： login、 shutdown、 halt、 reboot、 install、 mount、 umount、 chsh、 exit、 last；
◆ 文件处理命令： file、 mkdir、 grep、 dd、 find、 mv、 ls、 diff、 cat、 ln；
◆ 系统管理相关命令： df、 top、 free、 quota、 at、 lp、 adduser、 groupadd、 kill、 crontab；
◆ 网络操作命令： ifconfig、 ip、 ping、 netstat、 telnet、 ftp、 route、 rlogin、 rcp、 finger、 mail、 nslookup；
◆ 系统安全相关命令： passwd、 su、 umask、 chgrp、 chmod、 chown、 chattr、 sudo ps、 who；
◆ 其它命令： tar、 unzip、 gunzip、 unarj、 mtools、 man、 unendcode、 uudecode。  



### shell命令以及运行原理

Linux严格意义上说的是一个操作系统，我们称之为“核心（kernel） “ ，但我们一般用户，不能直接使用kernel。而是通过kernel的“外壳”程序，也就是所谓的shell，来与kernel沟通。如何理解？为什么不能直接使用kernel？



从技术角度， Shell的最简单定义：**命令行解释器**（command Interpreter）主要包含：

- 将使用者的命令翻译给核心（kernel）处理。
- 同时，将核心的处理结果翻译给使用者。  



对比windows GUI，我们操作windows 不是直接操作windows内核，而是通过图形接口，点击，从而完成我们的操作（比如进入D盘的操作，我们通常是双击D盘盘符.或者运行起来一个应用程序）。shell 对于Linux，有相同的作用，主要是对我们的指令进行解析，解析指令给Linux内核。反馈结果在通过内核运行出结果，通过shell解析给用户。



**Linux发行版 = 外壳程序 + 内核**

- 帮助理解：如果说你是一个闷骚且害羞的程序员，那shell就像媒婆，操作系统内核就是你们村头漂亮的且有让你心动的MM小花。你看上了小花，但是有不好意思直接表白，那就让你你家人找媒婆帮你提亲，所有的事情你都直接跟媒婆沟通，由媒婆转达你的意思给小花，而我们找到媒婆姓王，所以我们叫它王婆，它对应我们常使用的bash。  

**如果说媒婆是一个职业的话，那么王婆就是具体从事这个职业的人；shell叫命令行解释器，是所有外壳程序的总称，那么bash就是其中一种程序，bash是windows中使用的外壳程序**



`ps axj | grep bash` 查看bash进程  `kill xxxxx` 杀死进程xxxxx

<img src=".\Image\image-20220925164636653.png" alt="image-20220925164636653" style="zoom: 67%;" />



用户每登陆一次或者每登录一个用户，就需要产生一个bash进程



### Linux权限

**Linux下有两种用户：超级用户（root）、普通用户。**

**超级用户**：可以再linux系统下做任何事情，不受限制

**普通用户**：在linux下做有限的事情。



超级用户的命令提示符是“#”，普通用户的命令提示符是“$”。



> 命令： su [用户名]
> 功能：切换用户。
> 例如，要从root用户切换到普通用户user，则使用 su user。 要从普通用户user切换到root用户则使用 su
> root（root可以省略），此时系统会提示输入root用户的口令  



**举例**

- **切换为root** `su -`， 切换为普通用户 `su - AKANG`

<img src=".\Image\image-20220925165933916.png" alt="image-20220925165933916" style="zoom:67%;" />



使用建议，进root就是用`su -`，回AKANG使用ctrl+d回退就行，不要再用`su - AKANG`，每次su会产生一个bash，频繁使用su会产生太多的bash



修改当前用户密码`passwd` 修改指定用户密码`passwd xxx`

短暂提升用户权限 `sudo ` 需要添加信任关系，后面讲。



**什么是权限**？

一件事情是否允许被特定的人做。 权限 = 人 + 事物的属性

权限约束的是人，文件本身具有的天然的权限属性： 读r + 写w + 执行x



==**Linux中的用户类别**：==

1. 拥有者 owner                           u
2. 所属组 group 组员的权限         g
3. 其它     other  不是1和2的人    o

 

==**文件类型和访问权限**==



**文件类型**

> **d：目录文件**
> **-： 普通文件**  ： 文本、各种动静态库、可执行文件、源程序
> **l： 软链接**      ： 类似Windows的快捷方式
> **b：块设备文件**：硬盘、光驱等
> **p：管道文件**   ：通信
> **c：字符设备文件** ：键盘与显示器
> **s：套接口文件**  ：



Linux下一切皆文件

Linux系统不以后缀区分文件，但是gcc需要以后缀来区分



**访问权限**

![image-20220925211847412](.\Image\image-20220925211847412.png)

![image-20220925211905838](.\Image\image-20220925211905838.png)



==**文件权限值的表示方法**==

<img src=".\Image\image-20220928092049124.png" alt="image-20220928092049124" style="zoom: 33%;" />

### 文件权限值的相关设置方法

> ### **chmod**
>
>  **功能**： 设置文件的访问权限
> **格式**： chmod [参数] 权限 文件名
> **常用选项**：
> R -> 递归修改目录文件的权限
> **说明**：只有文件的拥有者和root才可以改变文件的权限



**chmod**

① 用户表示符+/-=权限字符

- +: 向权限范围增加权限代号所表示的权限
- -:  向权限范围取消权限代号所表示的权限
- =: 向权限范围赋予权限代号所表示的权限

**用户符号：**

- u：拥有者

- g：拥有者同组用
- o：其它用户

- a：所有用户  

**举例**

单个用户修改权限

<img src=".\Image\image-20220930085145131.png" alt="image-20220930085145131" style="zoom: 67%;" />

一次性个多个用户加权限

<img src=".\Image\image-20220930085453480.png" alt="image-20220930085453480" style="zoom: 67%;" />

对所有用户修改权限

<img src=".\Image\image-20220930092013968.png" alt="image-20220930092013968" style="zoom:67%;" />

> ### **chown**
>
> **功能**：修改文件的拥有者
>
> **格式**： chown [参数] 用户名 文件名  



**举例**

```c++
# chown user1 f1                    // 修改用户拥有者
# chown -R user1 filegroup1        
```

> ### **chgrp**
>
>  **功能**：修改文件或目录的所属组
> **格式**： chgrp [参数] 用户组名 文件名
> **常用选项**： -R 递归修改文件或目录的所属组  



**举例**

```
chgrp users /abc/f2
```



**总结**：如果想更改文件的拥有者和所属组，使用chown和chgrp命令，你把东西给别人或者把别人的东西拿来，或者更改文件所属组，可能需要短暂的权限提升（sudo/su -）。



> #### 用八进制数修改权限



<img src=".\Image\image-20220930104503299.png" alt="image-20220930104503299" style="zoom:67%;" />



> ### 目录的权限
>
> - **可执行权限**: 如果目录没有可执行权限, 则无法cd到目录中.
> - **可读权限**: 如果目录没有可读权限, 则无法用ls等命令查看目录中的文件内容.
> - **可写权限**: 如果目录没有可写权限, 则无法在目录中创建文件, 也无法在目录中删除文件  



现象1： 如果目录本身对other具有w权限，other可以删掉任何的目录下的文件；如果目录本身对other没有w权限，other不可以删掉任何文件

==那么如何做到，other可以在特定的目录下创建文件，并写入，但是不想让任何人删掉自己的文件？==



> ### 粘滞位
>
> **格式**：chmod o+t dir      
>
> **功能**：粘滞位的设置只能对目录设置，一般都是限制other权限的
>
> **结果**：对设置了粘滞位的目录，在该目录下，只有文件的拥有者/root可以删除



**场景**：有时候，有多个人，或者系统会有很多的临时数据，所有的临时文件放在系统的/tmp，此时需要放开权限让所有人可以创建和删除文件，但是只想让文件的拥有者自己删除自己的文件，这时候就需要粘滞位来实现。



**默认权限**：

普通文件，起始权限（666）

目录文件，起始权限（777）



**当一个目录被设置为"粘滞位"(用chmod +t),则该目录下的文件只能由**

- 一、超级管理员删除
- 二、该目录的所有者删除
- 三、该文件的所有者删除  



> ### umask
>
> **功能**：查看或者修改权限掩码，凡是在umask中出现的，都应该在起始权限中去掉
>
> **说明**：但实际上你所创建的文件和目录，看到的权限往往不是上面这个值。原因就是创建文件或目录的时候还要受到umask的影响。假设默认权限是mask，则实际创建的出来的文件权限是: **mask & ~umask** 
>
> **格式**： umask 权限值
> **注意**：将现有的存取权限减去权限掩码后，即可产生建立文件时预设权限。超级用户默认掩码值为0022，普通用户默认为0002  



**举例**

假设掩码 umask = 0002 ----- 000 000 010，先按位取反 ~umask = 111 111 101 ， 此时想去掉的位已经设置为0，不想去掉的是1，接着再按位与，结果就是去掉了000 000 010中1这个位置的权限



<img src=".\Image\image-20220930160039565.png" alt="image-20220930160039565" style="zoom:67%;" />

==修改默认权限（本次登录有效）==

- `umask 0333` 将默认的权限设置为(0)333，然后创建Test1目录，查看Test1的默认权限为r--，**我们的修改的是掩码umask ：011011011，目录的默认权限是777：111111111，用掩码处理过后就成为了100100100.**

<img src=".\Image\image-20220930160323901.png" alt="image-20220930160323901" style="zoom:67%;" />

### 关于权限的总结

目录的可执行权限是表示你可否在目录下执行命令。



- 如果目录没有-x权限，则无法对目录执行任何命令，甚至无法cd 进入目, 即使目录仍然有-r 读权限（这个地方很容易犯错，认为有读权限就可以进入目录读取目录下的文件）
- 而如果目录具有-x权限，但没有-r权限，则用户可以执行命令，可以cd进入目录。但由于没有目录的读权限  
- 所以在目录下，即使可以执行ls命令，但仍然没有权限读出目录下的文档。  

## Lesson 2 Linux常用工具

### Linux 软件包管理器 yum  

**什么是软件包**
在Linux下安装软件, 一个通常的办法是下载到程序的源代码, 并进行编译, 得到可执行程序.但是这样太麻烦了, 于是有些人把一些常用的软件提前编译好, 做成软件包(可以理解成windows上的安装程序)放在一个服务器上, 通过包管理器可以很方便的获取到这个编译好的软件包, 直接进行安装.软件包和软件包管理器, 就好比 "App" 和 "应用商店" 这样的关系.yum(Yellow dog Updater, Modified)是Linux下非常常用的一种包管理器. 主要应用在Fedora, RedHat,Centos等发行版上.



**关于 rzsz**

这个工具用于 windows 机器和远端的 Linux 机器通过 XShell 传输文件.

安装完毕之后可以通过拖拽的方式将文件上传过去.



**注意事项**

关于 yum 的所有操作必须保证主机(虚拟机)网络畅通!!!



可以通过 ping 指令验证

```
ping www.baidu.com
```

**查看软件包**

通过 yum list 命令可以罗列出当前一共有哪些软件包. 由于包的数目可能非常之多, 这里我们需要使用 grep 命令只筛选出我们关注的包. 例如:

```
yum list | grep lrzsz
```

结果如下:

```
lrzsz.x86_64 0.12.20-36.el7 @base  
```

**注意事项:**

- 软件包名称: 主版本号.次版本号.源程序发行号-软件包的发行号.主机平台.cpu架构.
- "x86_64" 后缀表示64位系统的安装包, "i686" 后缀表示32位系统安装包. 选择包时要和系统匹配.
- "el7" 表示操作系统发行版的版本. "el7" 表示的是 centos7/redhat7. "el6" 表示 centos6/redhat6.
- 最后一列, base 表示的是 "软件源" 的名称, 类似于 "小米应用商店", "华为应用商店" 这样的概念



**如何安装软件**
通过 yum, 我们可以通过很简单的一条命令完成 gcc 的安装.

```
sudo yum install lrzsz
```

yum 会自动找到都有哪些软件包需要下载, 这时候敲 "y" 确认安装.
出现 "complete" 字样, 说明安装完成.



**注意事项:**

- 安装软件时由于需要向系统目录中写入内容, 一般需要 sudo 或者切到 root 账户下才能完成.
- yum安装软件只能一个装完了再装另一个. 正在yum安装一个软件的过程中, 如果再尝试用yum安装另外一个软件, yum会报错.
- 如果 yum 报错, 请自行百度.



**如何卸载软件**



仍然是一条命令:

```
sudo yum remove lrzsz  
```

### Linux开发工具 vim

- IDE - VS2019 --- 集成开发环境



==什么是vim？==



- vim是一个文本编辑器，不能调试和运行代码。从定位上说和记事本没有差别。
- 多模式编辑器
  - 命令模式 - 默认打开是命令模式 ---> 按 i 进入插入模式
  - 插入模式 - ---> 按Esc 回退的Insert模式 ---> 按 shift+：进入底行模式
  - 底行模式 - wq保存并退出



![img](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F1635644%2F202003%2F1635644-20200320235833308-556504745.png&refer=http%3A%2F%2Fimg2020.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1668653424&t=ec6195baa1d39bd6fcdaa40a11b54c01)



#### vim详细介绍

- **正常/普通/命令模式(Normal mode)**
  控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入`Insert mode`下，或者到` last line mode`
- **插入模式(Insert mode)**
  只有在`Insert mode`下，才可以做文字输入，按`「ESC」`键可回到命令行模式。该模式是我们后面用的最频繁的编辑模式。
- **底行模式(last line mode)**
  文件保存或退出，也可以进行文件替换，找字符串，列出行号等操作。 在命令模式下，`shift+:` 即可进入该模式。要查看你的所有模式：打开vim，底行模式直接输入:`help vim-modes`

我这里一共有12种模式:`six BASIC modes`和`six ADDITIONAL modes`



==命令模式==



**光标相关**

h（左）j（下）k（上）l（右）



**光标位置锚点**

shift+^ (行首)  shift+$（行尾）

gg（起始行）shift+g（结束行）n+shift+g（跳到第n行）

w（按单词向前移动）b（按单词向后移动）



**文本操作**

yy：复制当前行

nyy：复制当前行及之后n行

p：粘贴

np：一次粘贴n行

u：撤销

ctrl+r： 撤销最近的撤销

dd：删除当前光标所在行

dd->p：剪切功能

shift+~：快速大小写切换

x：左向右，删除光标之后一个字符，支持nx

X：右向左，删除光标之前的一个字符，支持nX

r：替换一个字符，光标所在的字符，支持nr

shift+r：替换模式，直接进行多个内容的替换



==底行模式==



set nu：调出行号

set nonu：取消行号

vs+文件：多文件操作[ctrl+w+w]

w：保存

q：退出

！：强制[w!，q!，wq!]

替换当前行中的AAA为yyy：s/AAA/yyy/g



==vim配置==



vim配置在自己的配置文件中，只会影响自己的操作

root有自己的vim配置文件，只影响自己

**直接去gitee下载插件`vimforcpp`**

### gcc

==**gcc选项**==

> -E 只激活预处理,这个不生成文件,你需要把它重定向到一个输出文件里面
> -S 编译到汇编语言不进行汇编和链接
> -c 编译到目标代码
> **-o 文件输出到文件**
> -static 此选项对生成的文件采用静态链接
> -g 生成调试信息。GNU 调试器可利用该信息。
> -shared 此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库.
> -O0
> -O1
> -O2
> -O3 编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高
> -w 不生成任何警告信息。
> -Wall 生成所有警告信息  
>
> #### 分步编译
>

`gcc -E mytest.c`  开始进行翻译，完成预处理之后停下来

![image-20221117211841955](.\Image\image-20221117211841955.png)

<img src=".\Image\image-20221117212039858.png" alt="image-20221117212039858" style="zoom: 50%;" />

最后一步`gcc mytest.o -o mytest`

#### 两种直接编译的方式

![image-20221117214433197](.\Image\image-20221117214433197.png)

#### 查看链接的库

![image-20221118161043665](.\Image\image-20221118161043665.png)



在Linux中，静态库是`.a后缀文件`，动态库是`.so后缀文件`。gcc采用动态链接的方式产生可执行文件，还需要依赖第三方库。

![image-20221118162027319](.\Image\image-20221118162027319.png)



安装静态库：`sudo yum install glibc-static`

静态链接：`gcc mytest.c -o mytest_static -static`

### gdb调试程序

Linux默认情况下生成的可执行文件是release版本的，要想debug需要在编译的时候加上`-g`选项

开始调试：`gdb binFile` 退出：` ctrl + d `或` quit `调试命令：
`list／l 行号`：显示binFile源代码，接着上次的位置往下列，每次列10行。
`list／l 函数名`：列出某个函数的源代码。
`r或run`：运行程序。
`n 或 next`：单条执行。
`s或step`：进入函数调用
`break(b) 行号`：在某一行设置断点
`break 函数名`：在某个函数开头设置断点
`info break `：查看断点信息。
`finish`：执行到当前函数返回，然后挺下来等待命令
`print(p)`：打印表达式的值，通过表达式可以修改变量的值或者调用函数
`p 变量`：打印变量值。
`set var`：修改变量的值
`continue(或c)`：从当前位置开始连续而非单步执行程序
`run(或r)`：从开始连续而非单步执行程序
`delete breakpoints`：删除所有断点
`delete breakpoints n`：删除序号为n的断点
`disable breakpoints`：禁用断点
`enable breakpoints`：启用断点
`info(或i) breakpoints`：参看当前设置了哪些断点
`display 变量名`：跟踪查看一个变量，每次停下来都显示它的值
`undisplay`：取消对先前设置的那些变量的跟踪
`until X行号`：跳至X行
`breaktrace(或bt)`：查看各级函数调用及参数
`info（i) locals`：查看当前栈帧局部变量的值
`quit`：退出gdb  



### Linux项目自动化构建工具-make/Makefile

make是一条命令，makefile是一个文件 ，文件和文件之间的互相依赖关系

### Makefile的用法

就是在Makefile文件中写一些命令然后自动化调用

<img src=".\Image\image-20230220194331106.png" alt="image-20230220194331106" style="zoom: 50%;" />

==**原理**==

Makefile文件

```c++
hello:hello.o  // hello依赖于hello.o 将hello作为目标文件，然后寻找hello.o，如果找不到就去找后面的，类似于栈
    gcc hello.o -o hello // 单说这一行，是将hello.o文件进行处理，写入到hello中(-o就是写入的意思)
hello.o:hello.s // hello.o依赖于hello.s
    gcc -c hello.s -o hello.o 
hello.s:hello.i  // hello.s依赖于hello.i
    gcc -S hello.i -o hello.s 
hello.i:hello.c //hello.i依赖于hello.c
    gcc -E hello.c -o hello.i 
.PHONY:clean
clean:
	rm -f hello.i hello.s hello.o hello
```

1. make会在当前目录下找名字叫“Makefile”或“makefile”的文件。
2. 如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“hello”这个文件，并把这个文件作为最终的目标文件。
3. 如果hello文件不存在，或是hello所依赖的后面的hello.o文件的文件修改时间要比hello这个文件新（可以用 touch 测试），那么，他就会执行后面所定义的命令来生成hello这个文件。
4. 如果hello所依赖的hello.o文件不存在，那么make会在当前文件中找目标为hello.o文件的依赖性，如果找到则再根据那一个规则生成hello.o文件。（这有点像一个堆栈的过程）
5. 当然，你的C文件和H文件是存在的啦，于是make会生成 hello.o 文件，然后再用 hello.o 文件声明make的终极任务，也就是执行文件hello了。
6. 这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。
7. 在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。
8. make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦  

==使用流程==

1. 先写一个hello.c的程序，然后使用命令`ls > Makefile`，意思是将当前目录中仅有的hello.c文件写入Makefile中
2. 然后进入Makefile中写入依赖关系和命令
3. 在Makefile中，`hello:hello.o`，hello是目标文件，hello依赖于hello.o，下一行是要执行的命令
4. `.PHONY:clean`是定义一个伪目标，然后我们要执行clean后面的命令，需要执行`make clean`命令。.PHONY是修饰clean的。



<img src=".\Image\image-20230220202017049.png" alt="image-20230220202017049" style="zoom:50%;" />

**简写**

- 写依赖、依赖方
  \$@ --> 目标文件 【你想生成的可执行C文件】
  $^ --> 所依赖文件：【你写的C源文件名】

- 设置伪目标，用.PHONY指明目标名。

  ​	写明目标实现的方法，也就是指令。

### 缓冲现象

<img src=".\Image\image-20230220211259213.png" alt="image-20230220211259213" style="zoom:50%;" />

上图中，`printf("hello world")`这行代码中，**如果加入换行，那么执行结果就是先输出，然后过五秒结束；如果不加换行，那么执行结果为先等5秒然后输出。**

造成这个问题的原因是：**printf是将字符串输入到缓冲区中，然后显示器还没有刷新，显示器的刷新策略是行刷新，也就是会根据换行符来刷新。**

如果想立即刷新，就加入一行代码`fflush(stdout);`c语言会默认打开三个文件：stdin、stdout、stderr，分别对应键盘、显示器、显示器。

### 进度条

```c++
#include<stdio.h>
#include<string.h>
#include<unistd.h>
int main()
{
#define NUM 100
   char bar[NUM+1];
   memset(bar, '\0', sizeof(bar));

  const char *label="|/-\\";
  int i = 0;
  while(i <= 100)
  {
      printf("\033[31m[%-100s][%3d%%][%c]\r",bar,i,label[i%4]);
      fflush(stdout);
      bar[i] = '=';
      i++;
      usleep(50000);// 5秒走完100个# 50000微秒
  }
  printf("\n");
  return 0;                                                                                                                                          
}
```

### Git

判断是否安装git：`git --version`

克隆仓库：`git clone "地址"`

提交代码三个步骤

1. 将要提交的文件放到克隆好的仓库中，然后告诉git你要提交的文件：`git add 文件名`
2. 然后写提交声明：`git commmit -m "内容"`
3. 最后推送：`git push`

## Lesson 3 进程的概念

### 冯诺依曼体系结构

1. 输入设备：键盘，磁盘，网卡，显卡，话筒，摄像头等
2. 输出设备：显示器，磁盘，网卡，显卡，音响等
3. 存储器（内存）
4. 运算器&&控制器（CPU）

### 存储分级

<img src="https://img-blog.csdnimg.cn/20200102215347423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R5MTM0MzgxODk1MTk=,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 33%;" />



### 操作系统

**OS是什么**：一款专门针对软硬件资源进行管理工作的软件。

**OS为什么**：对下：管理好硬件资源。 对上：给用户提供稳定的，高效的，安全的运行环境。

**OS怎么办**：管理 ！分为决策和执行

1. 管理者和被管理者并不会直接打交道 
2. 如何管理你？对你做出各种决策，决策是要有依据的（你的属性数据）
3. 你的数据如何被管理者知道的？执行者，

 <img src=".\Image\image-20230221161155552.png" alt="image-20230221161155552" style="zoom:50%;" />



**校长如何管理学生**

1. 将一个学生的所数据聚合在一起：定义一个学生结构体   （描述一个学生）
2. 将多个学生的数据聚合，之间产生关联                            （将学生们组织起来）

**操作系统如何管理进程？** 先描述，再组织。将对目标的管理转化为对数据的管理。

描述进程的结构体 - PCB - 进程控制块

**操作系统如何向上为用户提供服务？**

操作系统OS不信任任何用户，所以提供一些**系统接口**（本质是函数）来提供服务。例如用printf是C语言提供的函数，在使用时会调用系统的一些接口来实现输出。

### 进程

**概念**：加载到内存的程序叫做进程（书本定义）。

**操作系统如何管理进程？** 

- 先描述：任何进程形成之前，操作系统都要为该进程创建PCB，进程控制块。在Linux系统中，PCB -> struct task_struct { // 进程的所有属性 }

- 再组织：



==**进程 = 程序文件 + 相关的数据结构**==

相关的数据结构 ----》PCD  struct task_struct {}  由操作系统自动创建

有了进程控制块，所有的进程管理任务与进程对应的程序毫无关系，与进程对应的内核创建的该进程的PCD强相关。

**task_struct 中的内容**

- **标示符**: 描述本进程的唯一标示符，用来区别其他进程。 **PID**

- **状态**: 任务状态，退出代码，退出信号等。

- **优先级**: 相对于其他进程的优先级。

- **程序计数器**: 程序中即将被执行的下一条指令的地址。

- **内存指针**: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针 **帮助我们找到进程的程序代码和数据**

- **上下文数据**: 进程执行时处理器的寄存器中的数据[休学例子，要加图CPU，寄存器]。

  在单CPU情况下，让每个进程在CPU上运行较短时间（如10ms），然后快速切换进程到CPU上运行，如此用户感受到进程在同时运行。

  进程实在切换的，进程可能会产生大量临时数据（保护上下文，恢复上下文），暂时存储在寄存器中

- **I/O状态信息**: 包括显示的I/O请求,分配给进程的I／ O设备和被进程使用的文件列表。

- **记账信息**: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。

- **其他信息**  

**Linux中查看进程的两种方式**

1. `ps axj | head -1 && ps axj | grep myproc`

2. `ls /目录/PID -al`

   <img src=".\Image\image-20230221204754898.png" alt="image-20230221204754898" style="zoom:50%;" />

   cwd : 当前目录

   exe ：正在执行的程序

**结束进程**

`kill -9 PID`

![image-20230221194310839](.\Image\image-20230221194310839.png)



**通过系统调用创建进程 - fork**

```c++
#include <iostream>
#include <unistd.h>

int main()
{
   fork(); // 创建一个子进程

   std::cout << "hello proc: " << getpid() << " hello parent: " << getppid() << std::endl;

   sleep(1); // 上面这一行会输出两次，让程序停一下可以保证输出结果看起来是两行                                             
   return 0;
}
```

**如何理解fork创建子进程**？

**fork的本质**是创建进程，系统里多了一个子进程，与进程相关的内核数据+进程的代码和数据在系统里面多了一份，我们只fork了，创建了子进程，但是子进程对应的代码和数据是**继承父进程**的代码和数据结构，内核数据task_struct会以父进程为模板，初始化子进程的task_struct，fork之后子进程和父进程的代码是**共享的**。虽然共享，但是为了保证进程的**独立性**，代码是不可别修改的，通过**写时拷贝**完成数据修改。



**创建子进程不是为了干和父进程一样的事情，那么如何让它干不一样的事情呢？** 通过fork的返回值来完成

**fork返回值**

1. 失败：返回值<0
2. 成功：给父进程返回子进程的pid，给子进程返回0

**如何理解有两个返回值？**

有两个执行流，发生了写时拷贝，父子进程都return

**fork之后谁先运行？** 不确定，由调度器决定

### 进程信息

**进程的状态信息在 task_struct  (PCB -- 进程控制块)**

**进程状态的意义**：方便OS快速判断进程，完成特定的功能，比如调度，本质是一种分类。

**具体的状态**

1. R -- 运行状态（running）。 **不一定**正在占有CPU(快速切换中)，当进程处于运行队列中，随时可以被执行的状态。

2. S -- 睡眠状态（sleeping）。 意味着进程在等待事件完成（这里的睡眠有时候也叫做可中断睡眠（interruptible sleep）。  

3. D -- 磁盘休眠状态（disk sleep）。有时候也叫不可中断睡眠状态（uninterruptible sleep），在这个状态的进程通常会等待IO的结束。**进程如果处于D状态不可被杀掉**

4. T -- 暂停状态（stopped）。

5. X -- 死亡（dead）。回收进程资源 = 进程相关的内核数据+程序代码和数据。

6. Z -- 僵尸状态（zombie）。**为什么要有僵尸状态？**辨别退出死亡原因！

   僵死状态（Zombies）是一个比较特殊的状态。当进程退出并且父进程（使用wait()系统调用,后面讲）没有读取到子进程退出的返回代码时就会产生僵死(尸)进程僵死进程会以终止状态保持在进程表中，并且会一直在等待父进程读取退出状态代码。所以，**只要子进程退出，父进程还在运行，但父进程没有读取子进程状态，子进程进入Z状态**。

   1. 进程的退出状态必须被维持下去，因为他要告诉关心它的进程（父进程），你交给我的任务，我办的怎么样了。可父进程如果一直不读取，那子进程就一直处于Z状态？是的！

   2. 维护退出状态本身就是要用数据维护，也属于进程基本信息，所以保存在task_struct(PCB)中，换句话说， Z状态一直不退出， PCB一直都要维护？是的！

   3. 那一个父进程创建了很多子进程，就是不回收，是不是就会造成内存资源的浪费？是的！因为数据结构对象本身就要占用内存，想想C中定义一个结构体变量（对象），是要在内存的某个位置进行开辟空间！

   4. 内存泄漏?是的！

   5. 如何避免？后面讲  

**孤儿进程**：父进程如果提前退出，那么子进程后退出，进入Z之后，那该如何处理呢？**父进程先退出，子进程就称之为“孤儿进程”**，孤儿进程被1号init进程领养，当然要有init进程回收喽。

### 进程优先级

**查看进程信息**

<img src=".\Image\image-20230224150824026.png" alt="image-20230224150824026" style="zoom:33%;" />



- **UID** : 代表执行者的身份
- **PID** : 代表这个进程的代号
- **PPID** ：代表这个进程是由哪个进程发展衍生而来的，亦即父进程的代号
- **PRI** ：代表这个进程可被执行的优先级，其值越小越早被执行
- **NI** ：代表这个进程的nice值（取值范围 -20~19）   $$PRI(new)=PRI(old)+nice$$

### 其他概念

- **竞争性**: 系统进程数目众多，而CPU资源只有少量，甚至1个，所以进程之间是具有竞争属性的。为了高效完成任务，更合理竞争相关资源，便具有了优先级
- **独立性**: 多进程运行，需要独享各种资源，多进程运行期间互不干扰
- **并行**: 多个进程在**多个CPU下**分别，同时进行运行，这称之为并行
- **并发**: 多个进程在**一个CPU下**采用进程切换的方式，在一段时间之内，让多个进程都得以推进，称之为并发  

### 环境变量

思考一个问题，在Linux中万物皆文件，命令，程序，工具都是文件，那么就是说命令和我自己写的c程序的可执行文件都是一样的，那么**为什么在运行系统命令的时候直接输就可以，而运行我的c程序的时候需要输入`./`来定位？**

原因就是**环境变量**，环境变量帮助系统去确认命令文件在哪里。

> **环境变量(environment variables)**一般是指在操作系统中用来指定操作系统运行环境的一些参数如：我们在编写C/C++代码的时候，在链接的时候，从来不知道我们的所链接的动态静态库在哪里，但是照样可以链接成功，生成可执行程序，原因就是有相关环境变量帮助编译器进行查找。环境变量通常具有某些特殊用途，还有在系统当中通常具有全局特性。

**将自己写的文件的路径加入到环境变量中**：`export PATH=$PATH:路径`

**查看环境变量路径：**`echo $PATH`

<img src=".\Image\image-20230224160740203.png" alt="image-20230224160740203" style="zoom:50%;" />

- **PATH** : 指定命令的搜索路径
- **HOME** : 指定用户的主工作目录(即用户登陆到Linux系统中时,默认的目录)
- **SHELL** : 当前Shell,它的值通常是/bin/bash。  

==编程语言中的变量本质是在**内存中开辟空间**，环境变量**本质是操作系统OS在内存/磁盘文件中开辟的空间，用来保存系统相关的数据**==

### 查看环境变量的名称

```c++
echo $NAME //NAME:你的环境变量名称  
```

### 和环境变量相关的命令

1. **echo**: 显示某个环境变量值
2. **export**: 设置一个新的环境变量
3. **env**: 显示所有环境变量
4. **unset**: 清除环境变量
5. **set**: 显示本地定义的shell变量和环境变量  

### 环境变量的组织方式

**理解main函数的参数及意义**

<img src=".\Image\image-20230224202415083.png" alt="image-20230224202415083" style="zoom:33%;" />

```c++
int main(int argc, char* argv[]) // argv[]里面存的是命令行的命令，将命令看作一个个字符串，argc是命令的个数
{
    
}
```

一个程序开始于对函数main()的调用。在这样做的时候，有两个参数被送给main(),**其中的一个描述了命令行参数的个数，通常称为==argc==**；另一个是**命令行参数的数组，通常称为==argv==**。命令行参数都是[字符串]，所以**argv的类型是char* [argc+1]**。**该程序的名字也作为argv[0]传进来**，所以argc的值至少是1。这个参数的表总以0结束，也就是说，argv[argc]==0。

所以说Linux中的命令的多个选项都是用main()的参数来实现的，举例如下

```c++
int main(int argc, char* argv[])
{
    if (argc != 2)
    {
        ptintf("Usage: %s -[a|h]\n", argv[0]);
    }
    
    if (strcmp(argv[1], "-h") == 0)
    {
        printf("hello world!\n");
    }
    else if (strcmp(argv[1], "-a") == 0)
    {
        printf("hello AK\n");
    }
    else
    {
        printf("hello\n");
    }
    
    return 0;
}
```

### 通过代码如何获取环境变量

```c++
#include <stdio.h>
int main(int argc, char *argv[], char *env[])
{
	int i = 0;
	for(; env[i]; i++)
    {
		printf("%s\n", env[i]);
	}
	return 0;
}
```

### 通过系统调用获取或设置环境变量

```c++
#include <stdio.h>
#include <stdlib.h>

int main()
{
	printf("%s\n", getenv("PATH"));
	return 0;
}
```

环境变量具有**全局性质**，，环境变量可以被子进程继承下去

### 程序地址空间

在学习C语言阶段，对程序在内存中的地址理解如下图

<img src=".\Image\image-20230225195337164.png" alt="image-20230225195337164" style="zoom: 50%;" />

在Linux中打印出父进程和子进程的地址会发现地址是一样的，这说明C/C++中的程序地址不是物理地址，而是**虚拟地址**！

**进程地址虚拟空间**

每个进程都有一个地址空间，都认为自己在独占物理内存。如何管理进程的地址，**先描述，再组织**，进程除了有PCD，还有`struct mm_struct{}`

==操作系统给每个进程都花了一张大饼，每个进程都以为自己得到了全部的财产==

**进程地址空间**

进程地址空间本质是内核中的一种数据类型 struct mm_struct {}

**银行就是操作系统，我们把钱存在银行，我们的钱看起来在我们的账户上，实际上也许我们的钱已经被贷给其他人了，别人可用通过数据的方式给我们画大饼**

==每个进程都认为地址空间是按照4GB空间划分的，每个进程都认为自己拥有4GB==



**进程地址空间和物理内存的关系**

<img src=".\Image\image-20230226104334212.png" alt="image-20230226104334212" style="zoom:50%;" />



**为什么要弄一个虚拟地址，为什么不让进程直接在物理内存上运行，为什么要加入中间层页表？**

类似小时候你妈妈为了防止你乱花钱帮你保存压岁钱一样，当你需要花钱的时候需要管妈妈要，妈妈会教你如何合理花钱。操作系统也是为了更好管理进程才弄的虚拟地址。妈妈就是操作系统，页表就是妈妈管理压岁钱的工具。

**为什么有地址空间？**（专业来说）

1. 通过添加一层软件层，完成有效的对进程操作内存进行风险管理（权限管理），本质是为了保护物理内存以及各个进程的数据安全。
2. **将内存申请和内存使用的概念在时间划分清楚**，通过虚拟地址空间来屏蔽底层申请内存的过程，达到进程读写内存和OS进行内存管理操作在软件上的分离。（你申请1000字节的内存，但是你并不是申请下来立马就要用，给你但是你不用岂不是很浪费，所以操作系统其实不会立马真的给你1000字节，而是先答应，等你用的时候随时再给你）
3. 站在CPU和应用层的角度，进程同意可以看做统一使用4GB内存空间，而且每个区域都是相对确定的

**解释：**

1. **每个进程都认为自己有4GB内存**。因为操作系统通过页表将进程映射到整个虚拟的地址空间中，而且每个空间区域的相对位置，是比较确定的。

### 理解

父子进程的地址实际上是虚拟的，比如说父子进程中都有变量a，然后在运行过程中子进程将a修改，修改后父子进程中a的值不同，但是打印a的地址却是一样的，这表明我们看到的进程的地址实际上是虚拟的，它是通过页表映射的。具体来说就是，我们的进程肯定是在物理内存上运行的，但不是我们想象的在一块内存上，而是可能分散在各处，我们看到进程地址空间是操作系统通过页表创建的虚拟地址空间，这样做就相当于操作系统统一管理和调度了真实的物理内存。



## Lesson 4 进程控制

### fork()创建进程

> 在linux中fork函数时非常重要的函数，它从已存在进程中创建一个新进程。新进程为子进程，而原进程为父进程
>
> 
>
> #include <unistd.h>
> pid_t fork(void);
> **返回值：**自进程中返回0，父进程返回子进程id，出错返回-1  



进程调用fork，当控制转移到内核中的fork代码后，内核做

- 分配新的内存块和内核数据结构给子进程
- 将父进程部分数据结构内容拷贝至子进程
- 添加子进程到系统进程列表当中
- fork返回，开始调度器调度

### 写时拷贝

就是子进程和父进程共享某一段代码，当子进程或者父进程要修改程序数据时，将其再拷贝一份，重新跟程序地址映射起来。如下图，**通常父子代码共享，父子再不写入时，数据也是共享的，==当任意一方试图写入，便以写时拷贝的方式各自一份副本==**


<img src=".\Image\image-20230226162301558.png" alt="image-20230226162301558" style="zoom:50%;" />

**注意**：创建进程有很高的成本，也许你只创建了一个占用内存很小的进程，但是操作系统需要为这个进程创建一些数据结构来维护这个进程。

### 进程终止

`echo $?` ：输出最近一次进程的退出码

![image-20230301093910735](.\Image\image-20230301093910735.png)

**ls程序（命令）异常退出后退出码为2，正常退出时的退出码为0**

<img src=".\Image\image-20230301094139841.png" alt="image-20230301094139841" style="zoom:50%;" />

**退出码：**

- 0 ：sucess
- !0：failed

**exit()**

<img src=".\Image\image-20230301102607105.png" alt="image-20230301102607105" style="zoom:50%;" />

1. **exit()在任意地方调用，都代表终止进程，参数是退出码**
2. **main函数的return，代表程序退出**
3. **_exit终止进程，强制终止，不要进行进程后的收尾工作，例如缓冲区刷新**

<img src=".\Image\image-20230301110315968.png" alt="image-20230301110315968" style="zoom: 33%;" />





**进程退出OS层面干的事情：free PCB、free mm_struct、free页表和各种映射关系，代码+数据申请的空间也要释放掉。**

### 进程等待

> 进程wait是什么？父进程fork之后，需要通过wait/waipid知道子进程的执行情况

**为什么要让父进程等待呢？**

1. 通过获取子进程信息，能够得知子进程的执行结果。
2. 可以保证：时序问题 -- 子进程先退出，父进程后退出。
3. 子进程退出的时候会先进入僵尸状态，会造成内存泄漏问题，需要通过父进程wait释放子进程占用的资源

### waitpid()

> ```
> pid_ t waitpid(pid_t pid, int *status, int options);
> ```
>
>**返回值：**
> 			当正常返回的时候waitpid返回收集到的子进程的进程ID；
> 			如果设置了选项**WNOHANG,**而调用中waitpid发现没有已退出的子进程可收集,则返回0；
> 			如果**调用中出错,则返回-1,**这时errno会被设置成相应的值以指示错误所在；
> **参数**：
> 			**pid：**
> 				Pid=-1,等待任一个子进程。与wait等效。
> 				Pid>0.等待其进程ID与pid相等的子进程。
> 			**status:**
> 				**WIFEXITED(status):** 若为正常终止子进程返回的状态，则为真。（查看进程是否是正常退出）
> 				**WEXITSTATUS(status):** 若WIFEXITED非零，提取子进程退出码。（查看进程的退出码）
> 			**options:**
> 				**WNOHANG**: 若pid指定的子进程没有结束，**则waitpid()函数返回0**，不予以等待（**父进程干自己的事情**，持续查看子进程是否结束）。若正常结束，则返回该子进程的ID  

**获取子进程的status**

> - wait和waitpid，都有一个status参数，该参数是一个输出型参数，由操作系统填充。
> - 如果传递NULL，表示不关心子进程的退出状态信息。
> - 否则，操作系统会根据该参数，将子进程的退出信息反馈给父进程。
> - status不能简单的当作整形来看待，可以当作位图来看待，具体细节如下图（只研究status低16比特位）  

<img src=".\Image\image-20230302103444341.png" alt="image-20230302103444341" style="zoom:33%;" />

### bash

bash是命令行启动的所有进程的父进程

bash一定是通过wait的方式得到子进程的退出结果，所以我们能看到echo $? 可以查到所有子进程的进程代码



**阻塞的本质**：其实是进程的PCB被放入了等待队列，并将进程的状态改为S状态

**返回的本质**：进程的PCB从等待队列拿到R队列，从而被CPU调度

### 进程程序替换

**替换原理**

> 用fork创建子进程后执行的是和父进程相同的程序(但有可能执行不同的代码分支),子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时,**该进程的用户空间代码和数据完全被新程序替换,**从新程序的启动例程开始执行。调用exec并不创建新进程,所以调用exec前后该进程的id并未改变

**进程不变，仅仅替换当前进程的代码和数据的技术，叫做进程的程序替换**

```c++
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/types.h>
#include<sys/wait.h>
//#include<stdlib.h>

int main()
{
    printf("I am a process!, pid: %d\n", getpid());

    execl("/usr/bin/ls", "ls", "-a", "-l", NULL); // excel执行程序替换

    printf("hahahahahahahahhaha\n");

    printf("hahahahahahahahhaha\n");
    printf("hahahahahahahahhaha\n");
    printf("hahahahahahahahhaha\n");
    printf("hahahahahahahahhaha\n");
    printf("hahahahahahahahhaha\n");
    //printf("I am a child process!, pid: %d, ppid: %d\n", getpid(), getppid());

    //return 0;

//    pid_t id = fork();
//    if(id == 0)
//    {
//        // child
//        int cnt = 5;
//      while(cnt)
//        {
//            printf("child[%d] is running: cnt is : %d\n",getpid(), cnt);
//            cnt--;
//            sleep(1);
//        }
//        exit(11);
//    }
//
//    sleep(10);
//    printf("father wait begin!\n");
//
//    //pid_t ret = wait(NULL);
//    //pid_t ret = waitpid(id, NULL, 0); // 等待指定id的子进程
//    //pid_t ret = waitpid(id, NULL, 0); // 等待任一子进程，等价于wait()
//    int status = 0;
//    pid_t ret = waitpid(id, &status, 0);
//    if (ret > 0)
//    {
////        printf("father wait : %d, success, status exit code: %d, status exit signal: %d \n", ret, (status>>8)&0xFF, status&0x7F );
//   
//        printf("father wait : %d, success, status exit code: %d, status exit signal: %d \n", ret, WEXITSTATUS(status), WIFEXITED(status));
//    }
//    else
//    {
//        printf("father wait failed!\n");
//    }
//
//    sleep(10);
//
//
}
```

**为什么要进行程序替换？** 想让子进程执行一个“全新的程序”，又不想新建新的进程

### exec之类的函数使用

<img src=".\Image\image-20230313205624116.png" alt="image-20230313205624116" style="zoom: 50%;" />

```c++
#include <unistd.h>
int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg, ...,char *const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);  
```

**这些函数如果调用成功则加载新的程序从启动代码开始执行,不再返回。如果调用出错则返回-1，所以exec函数只有出错的返回值而没有成功的返回值**  

**==上面的函数都是exec+某个字母，具体的含义如下：==**

- l(list) : 表示参数采用列表

- v(vector) : 参数用数组
- p(path) : 有p自动搜索环境变量PATH
- e(env) : 表示自己维护环境变量  

**execle使用演示**

==创建一个myload.c文件，在里面执行myexe.c，execle的作用体现在可以自己维护环境变量，如果单纯运行myexe.c就打印的时系统的环境变量，如果在myload.c里面使用execle执行myexe.c那么打印的就是myload.c里面的环境变量。==

```c++
// myexe.c

#include<stdio.h>

int main()
{
    extern char** environ;
    for (int i = 0; environ[i]; i++)
    {
        printf("%s\n", environ[i]);
    }
    printf("My exe running ... done\n");

    return 0;
}

```

```c++
// myload.c

#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/wait.h>

int main()
{
    if (fork() == 0)
    { // child        
        printf("command begin...\n");
//        //execl("/usr/bin/ls"/*你要执行谁*/, "ls", "-a", "-l", "-i", /*你想怎么执行，命令行如何执行*/NULL);
//        char* argv[] = {"ls", "-a", "-l", "-i", NULL};
//        execv("/usr/bin/ls", argv); // 与execl函数没有本质区别，只是传参方式不同
//
        //execl("./myexe", "myexe", NULL);
        char* env[] = { 
            "MYENV=hahahahhahahaha", 
            "MYENV1=hahhahahhahahhahah", 
            "MYENV2=hahahahhahahhaha", 
            "MYENV3=hahahahhahahhaha", 
            NULL};
        execle("./myexe", "myexe", NULL, env);
        printf("command end...\n");
        exit(1);
    }

    waitpid(-1, NULL, 0);

    printf("wait child susess!\n");

    return 0;
}
```

Makefile文件的内容，一次性执行两个c文件的编译

```shell
.PHONY:all
all: myexe myload
myexe:myexe.c
	gcc -o $@ $^ -std=c99
myload:myload.c
	gcc -o $@ $^
.PHONY:clean
clean:
	rm -f myload myexe 
```

### 简易版shell

```c++
#include<stdio.h>
#include<string.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/wait.h>

#define NUM 128
#define CMD_NUM 64

int main()
{

    char* argv[CMD_NUM];
    char command[NUM];
    for (;;)
    {
        // 1. 打印提示符
        command[0] = 0; // 用这种方式，可以做到O(1)时间复杂度，清空字符串
        printf("[who@myhostname mydir]# ");
        fflush(stdout);

        // 2. 获取命令字串
        fgets(command, NUM, stdin);
        command[strlen(command) - 1] = '\0'; 
        printf("echo: %s\n", command);
       
        // 3. 解析命令字符串 "ls -a -b -c\0"
        const char* sep = " ";
        argv[0] = strtok(command, sep);
        int i = 1;
        while(argv[i] = strtok(NULL, sep))
        {
            i++;
        }
        
        /* 测试一下有没有解析好字符串
        for (i = 0; argv[i]; i++)
        {
            printf("argv[%d]: %s\n", i, argv[i]);
        }
        sleep(1);
        */
        
        // 4. 检测命令是否是shell本身要执行的，内建命令
        if (strcmp(argv[0], "cd") == 0)
        {
            if (argv[1] != NULL)
            {
                chdir(argv[1]);
                continue;
            }
        }
        
        // 5. 执行第三方命令
        if (fork() == 0)
        {
            // child
            execvp(argv[0], argv);
            exit(1);
        }
		
        int status = 0;
       
        waitpid(-1, &status, 0);
        printf("exit code: %d", (status>>8)&0xFF);

    }
    return 0;
}
```

## Lesson 5 基础IO

### 文件操作

<img src=".\Image\image-20230314214750508.png" alt="image-20230314214750508" style="zoom: 50%;" />

对于文件操作的函数最终都是**访问硬件**（显示器、键盘、文件（磁盘）），OS是硬件的管理者，所有语言上的对文件的操作**必须贯穿OS**，操作系统不相信任何人，访问操作系统，需要**通过系统调用接口**的，几乎所有的语言fopen，fclose，fread，fwrite，fgets，fputs，fgetc，fputc等底层一定需要使用**OS提供的系统调用**。

### 文件的系统调用接口

#### 标志位如何传递？（接口中的一个参数）

```c
#define O_WRONLY 0x1  // 0000 0001  只写
#define O_RDONLY 0x2  // 0000 0010  只读
#define O_CREAT 0x4   // 0000 0100  创建
// 这些标志宏只有一个bit位为1
// 使用举例
int fd = open("./log.txt", O_WRONLY | O_CREAT, 0644);
// 解释： 第二个参数的是用来传递标志，如果想传递多个标志，那就让他们按位或，相当于累加起来了，
// 操作系统拿到之后再按位与，判断哪些标志位被设置为了1
```

#### 文件描述符fd（接口的返回值）

Linux进程默认情况下会有3个缺省打开的文件描述符，分别是**标准输入0**， **标准输出1**， **标准错误2.**

0,1,2对应的物理设备一般是：键盘，显示器，显示器

<img src=".\Image\image-20230315210948488.png" alt="image-20230315210948488" style="zoom:50%;" />

> **fd本质是内核中进程和文件关联的数组下标**

==为什么这么说？==

1. 首先看操作系统底层，我们关注操作系统对于底层硬件的控制

2. 操作系统需要进行文件管理和进程管理，一个进程可以打开多个文件，那么进程和文件之间是如何联系的呢？

   <img src=".\Image\image-20230315211533143.png" alt="image-20230315211533143" style="zoom: 33%;" />

3. 上图中解释了进程和文件之间的联系。操作系统创建一个进程之后，通过struct_task来管理进程，进程中有一个指向文件结构体的指针数组struct struct_file*，里面存储着指向其要操作的文件，fd就是存储的这些指针在指针数组中的下标。

   <img src=".\Image\image-20230315214220222.png" alt="image-20230315214220222" style="zoom:33%;" />

   

4. 至于操纵外设，都是创建一个文件来操作，读和写都是由驱动层来进行的，所以在操作系统看来一切皆文件。

**文件描述符的分配规则**

给新文件分配的fd，是从fd_array中找一个最小的，没有被使用的，作为新的fd。



**所以输入输出还能这些实现**

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
int main()
{
	char buf[1024];
	ssize_t s = read(0, buf, sizeof(buf)); // 返回值s是实际读到的字节个数
	if(s > 0)
    {
		buf[s] = 0;
		write(1, buf, strlen(buf)); // 1代表标准输出 -> 显示器
		write(2, buf, strlen(buf)); // 2代表标准错误 -> 显示器
	}
	return 0;
}
```

所有的文件操作，表现上是不是都是进程执行对应的函数，进程对文件的操作，要操作必须要打开文件，将文件相关的属性信息加载到内存，操作系统中存在大量的进程，一个进程可以打开多个文件，系统中存在很多打开的文件，那么操作系统如何管理这些文件？先描述，再组织。使用struct file{}结构体描述文件的一些属性。

#### write()函数的描述

<img src=".\Image\image-20230315194947031.png" alt="image-20230315194947031" style="zoom:50%;" />

#### 一个写文件的例子

```c
#include<stdio.h>
#include<unistd.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<string.h>

int main()
{
    int fd = open("./log.txt", O_CREAT | O_WRONLY, 0644);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
  
    const char* msg = "hello world!\n";
  
    int cnt = 5;
    while (cnt)
    {
        write(fd, msg, strlen(msg)); // 是否需要写入\0? 不需要，'\0'作为字符串的结束，只是C的规定！
        cnt--;
    }                                                                                                                                                  
    
    fclose(fd);
    
    return 0;
}
```

#### 磁盘文件

如果一个文件没有被打开，这个文件在哪里？在磁盘上

如果这个文件是空的，那么占不占磁盘空间？肯定占用，文件具有文件属性，文件属性也是数据，也需要占用磁盘来存储。

**磁盘文件 = 文件内容 + 文件属性**

对文件操作包括：对文件内容操作，对文件属性操作

#### 输出重定向

<img src=".\Image\image-20230315222141976.png" alt="image-20230315222141976" style="zoom: 33%;" />

<img src=".\Image\image-20230315222201600.png" alt="image-20230315222201600" style="zoom:33%;" />



**上面的图干了啥？**

1. 首先看代码，`close(1)`，0对应标准输入、1对应标准输出、2对应标准错误，close(1)表示将标准输出对应的文件给关闭了
2. 接下来一行代码中创建了`log.txt`文件，根据操作系统分配文件描述符的规则，此时最小的为文件描述符1是空闲的，所以log.txt文件的文件描述符为1
3. 接下来有很多行`printf`，我们主管理解的printf是将字符串打印到显示器上，这个过程本质上是对标准输出进行打印，标准输出对应的是一个文件，该文件的文件描述符为1
4. 此时我们的**log.txt的文件描述符为1**，因此将所有的内容都打印到了log.txt文件中

上面的过程可以形象理解为，皇宫门口守门的小太监，他只认进程宫门的要牌，不管是谁只要有要牌就可以进皇宫，没有就不行。printf就是那个小太监，他只认文件描述符为1的文件。

#### 输入重定向

```c++
#include<stdio.h>
#include<unistd.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<string.h>

int main()
{
    close(0);
    int fd = open("./log.txt", O_RDONLY);
    // fd = 0
    printf("fd: %d\n", fd);
    char line[128];
    while (fgets(line, sizeof(line) - 1, stdin)) // stdin -> FILE* -> FILE 是一个结构体 -> fd == 0 
    {
        printf("%s", line);
    }
    
    return 0;
}
```

这个输入输出重定向其实就是更改了文件指示符指向的文件，从而使得输入的对象变化了。

**父子进程与文件的关系**

父进程如果曾经打开了标准输入，标准输出，标准错误？？子进程也会继承下去。

为什么我们的所有的进程都会默认打开标准输入，标准输出，标准错误？？因为bash！！

==父进程中打开的文件的文件描述符，子进程会全部继承，也就是说子进程也能对父进程打开的文件进行操作。但是有一个很重要的点是，子进程创建之后父子进程再打开或者关闭文件，互不影响！==

#### 缓冲区

**用户级缓冲区：**我们在向屏幕打印字符串的时候，如果不加`'\n'`，那么字符串内容会被加载到缓冲区，等程序执行完的时候刷新到屏幕，这就是用户及缓冲区，因此我们之前写进度条程序的时候用到了`ffush`函数来使屏幕即时刷新

**系统级缓冲区：**我们使用输出重定向将内容输入到文件的时候，如果在程序结尾关闭了要输入的那个文件，那么我们的内容就不会被输入到那个文件中，这是因为存在系统级缓冲，我们的内容在进程退出的时候需要刷新FILE内部的数据到OS缓冲区，然后OS再写入到磁盘文件，如果关闭了对应的文件，进程结束时没有将数据刷新到OS缓冲区，那么也就如法写入到我们想要写入的文件，就无法输出成功了。



**刷新策略**（用户到OS，OS到硬件）

1. 立即刷新（不缓冲）
2. 行刷新（行缓冲'\n'），比如显示器打印
3. 缓冲区满了，才刷新（全缓冲），比如，往磁盘文件中写入



```shell
[AKANG@VM-8-9-centos 409]$ cat redir.c
#include<stdio.h>
#include<unistd.h>
#include<string.h>

int main()
{
    // 系统接口
    const char *msg1 = "hello 标准输出\n";
    write(1, msg1, strlen(msg1));

    // C语言接口
    printf("hello printf\n"); // stdout -> FILE* -> FILE struct -> 1. fd  2. buffer -> 刷新策略 -> 目标文件类别
    fprintf(stdout, "hello fprintf\n"); // stdout
    fputs("hello fputs\n", stdout);

    fork(); // 创建子进程时会发生写时拷贝，会将缓冲区的内容刷新一遍，也即写入到屏幕


    return 0;
}
[AKANG@VM-8-9-centos 409]$ cat log.txt
[AKANG@VM-8-9-centos 409]$ make
gcc -o redir redir.c
[AKANG@VM-8-9-centos 409]$ ./redir
hello 标准输出
hello printf
hello fprintf
hello fputs
[AKANG@VM-8-9-centos 409]$ ./redir > log.txt
[AKANG@VM-8-9-centos 409]$ cat log.txt
hello 标准输出  // 系统接口不受影响，C语言接口重复了
hello printf
hello fprintf
hello fputs
hello printf
hello fprintf
hello fputs
[AKANG@VM-8-9-centos 409]$ 
```

**iostream,fstream**给我们提供了缓冲区，endl类似于'\0'，作用的就是刷新C++流中的数据到屏幕

### 理解文件系统

磁盘太大管理不方便，因此对磁盘进行分区管理。

磁盘的管理：1.分区 2. 格式化（写入文件系统）

#### inode

<img src=".\Image\image-20230318150503656.png" alt="image-20230318150503656" style="zoom: 50%;" />



Linux ext2文件系统，上图为磁盘文件系统图（内核内存映像肯定有所不同），磁盘是典型的块设备，硬盘分区被划分为一个个的block。一个block的大小是由格式化的时候确定的，并且不可以更改。例如mke2fs的-b选项可以设定block大小为1024、2048或4096字节。而上图中启动块（Boot Block）的大小是确定的， 

- **Block Group：**ext2文件系统会根据分区的大小划分为数个Block Group。而每个Block Group都有着相同的结构组成。政府管理各区的例子
- **超级块（Super Block）：**存放文件系统本身的结构信息。记录的信息主要有：bolck 和 inode的总量，未使用的block和inode的数量，一个block和inode的大小，最近一次挂载的时间，最近一次写入数据的时间，最近一次检验磁盘的时间等其他文件系统的相关信息。Super Block的信息被破坏，可以说整个文件系统结构就被破坏了
- **GDT，Group Descriptor Table：**块组描述符，描述块组属性信息，有兴趣的同学可以再了解一下
- **块位图（Block Bitmap）：**Block Bitmap中记录着Data Block中哪个数据块已经被占用，哪个数据块没有被占用
- **inode位图（inode Bitmap）：**每个bit表示一个inode是否空闲可用。**i节点表**:存放文件属性，如文件大小，所有者，最近修改时间等
- **数据区：**存放文件内容  

将属性和数据分开存放的想法看起来很简单，但实际上是如何工作的呢？我们通过touch一个新文件来看看如何工作  

```shell
[root@localhost linux]# touch abc
[root@localhost linux]# ls -i abc
263466 abc
```

<img src=".\Image\image-20230319103546635.png" alt="image-20230319103546635" style="zoom:50%;" />



**创建一个新文件主要有一下4个操作：**

1. **存储属性**
   内核先找到一个空闲的i节点（这里是263466）。内核把文件信息记录到其中。
2. **存储数据**
   该文件需要存储在三个磁盘块，内核找到了三个空闲块：300，500，800。将内核缓冲区的第一块数据复制到300，下一块复制到500，以此类推。
3. **记录分配情况**
   文件内容按顺序300，500，800存放。内核在inode上的磁盘分布区记录了上述块列表。
4. **添加文件名到目录**
   新的文件名abc。linux如何在当前的目录中记录这个文件？内核将入口（263466，abc）添加到目录文件。文件名和inode之间的对应关系将文件名和文件的内容及属性连接起来。  

目录也是一个文件，删除文件时并不需要删除文件的数据和属性，只需要将inode Bitmap里面标志置为0即可。



**查看inode**

<img src=".\Image\image-20230320100436690.png" alt="image-20230320100436690" style="zoom:50%;" />

#### 软链接

**应用场景：**在一个目录中想执行另一个目录中的文件，要是每次都输路径会很麻烦，所以建立软链接，类似于windows中的快捷方式

==软链接是由自己独立的inode的！软链接是一个独立文件！！有自己的inode属性，也有自己的数据块（保存的是指向文件的所在路径+文件名）==

```shell
[AKANG@VM-8-9-centos 409]$ ln -s log.txt log_s
[AKANG@VM-8-9-centos 409]$ ll
total 24
lrwxrwxrwx 1 AKANG AKANG    7 Mar 19 10:43 log_s -> log.txt
-rw-rw-r-- 1 AKANG AKANG   97 Mar 17 12:00 log.txt
-rw-rw-r-- 1 AKANG AKANG   61 Mar 17 10:18 Makefile
-rwxrwxr-x 1 AKANG AKANG 8584 Mar 17 12:00 redir
-rw-rw-r-- 1 AKANG AKANG  432 Mar 17 11:57 redir.c
```

<img src=".\Image\image-20230319114329560.png" alt="image-20230319114329560" style="zoom:33%;" />

上图中abc是原文件，def是硬链接，abc.s是软链接

#### 硬链接

硬链接本质根本不是一个独立的文件，而是一个文件名和inode编号的映射关系，因为自己没有独立的inode！创建硬链接本质是在特定目录下，填写一个文件

我们看到，真正找到磁盘上文件的并不是文件名，而是inode。 其实在linux中可以让多个文件名对应于同一个
inode。 

```
[root@localhost linux]# touch abc 
[root@localhost linux]# ln abc def 
[root@localhost linux]# ls -1i
abc def 263466 abc 263466 def  
```

#### acm

- **Access** 最后访问时间 **（在新的Linux内核中，Access时间不会被立即更新，而是有一定时间间隔，OS才会自动更新，文件访问太高频了，如果经常刷新会造成很大消耗）**
- **Modify** 文件内容最后修改时间
- **Change** 文件属性最后修改时间  

当我们修改文件内容的时候，有可能也修改了文件的属性，比如：可能会更改文件大小的属性



**在使用Makefile的时候，会根据access时间来决定要不要执行，如果源文件已经编译过且没有修改，那么就不会再次编译**，也就是说如果编译后的文件更新那么就不用再编译。

<img src=".\Image\image-20230320104338780.png" alt="image-20230320104338780" style="zoom:50%;" />

### 动静态库

一般库分两种：**动态库** 和 **静态库**

在Linux中

- 如果是动态库：库文件是以.so作为后缀的！
- 如果是静态库：库文件是以.a作为后缀的

#### 关于查看静态库和动态库的命令

==ldd 查看可执行程序依赖库 ，file查看动静态链接==

#### 使用静态库编译

```shell
[AKANG@VM-8-9-centos 416]$ cat test.cc
#include<iostream>

int main()
{
    std::cout << "hello C++!" << std::endl;

    return 0;
}
[AKANG@VM-8-9-centos 416]$ cat Makefile
test_static:test.cc
	g++ -o $@ $^ -static
.PHONY:clean
clean:
	rm -f test
	
[AKANG@VM-8-9-centos 416]$ ./test_static
hello C++!
[AKANG@VM-8-9-centos 416]$ file test_static
test_static: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=8799342f7e8238760890ffc77906daf8961bc06a, not stripped
[AKANG@VM-8-9-centos 416]$ ldd test_static
	not a dynamic executable
```

使用静态编译的时候，在后面加上`-static`

#### 使用动态库编译

```shell
[AKANG@VM-8-9-centos 416]$ g++ -o test test.cc
[AKANG@VM-8-9-centos 416]$ ldd test
	linux-vdso.so.1 =>  (0x00007ffed4fd3000)
	libstdc++.so.6 => /home/AKANG/.VimForCpp/vim/bundle/YCM.so/el7.x86_64/libstdc++.so.6 (0x00007f0dcaaba000)
	libm.so.6 => /lib64/libm.so.6 (0x00007f0dca7b8000)
	libgcc_s.so.1 => /lib64/libgcc_s.so.1 (0x00007f0dca5a2000)
	libc.so.6 => /lib64/libc.so.6 (0x00007f0dca1d4000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f0dcae3b000)
[AKANG@VM-8-9-centos 416]$ file test
test: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=4b6af997e664fa8fd919516aafdae3cb5fdadf29, not stripped
```

**Linux很多命令都是用C语言写的**

```shell
[AKANG@VM-8-9-centos 416]$ which ls
alias ls='ls --color=auto'
	/usr/bin/ls
[AKANG@VM-8-9-centos 416]$ file /usr/bin/ls
/usr/bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=c8ada1f7095f6b2bb7ddc848e088c2d615c3743e, stripped
[AKANG@VM-8-9-centos 416]$ ldd /usr/bin/ls
	linux-vdso.so.1 =>  (0x00007ffd2ebbf000)
	libselinux.so.1 => /lib64/libselinux.so.1 (0x00007fed38eb9000)
	libcap.so.2 => /lib64/libcap.so.2 (0x00007fed38cb4000)
	libacl.so.1 => /lib64/libacl.so.1 (0x00007fed38aab000)
	libc.so.6 => /lib64/libc.so.6 (0x00007fed386dd000)
	libpcre.so.1 => /lib64/libpcre.so.1 (0x00007fed3847b000)
	libdl.so.2 => /lib64/libdl.so.2 (0x00007fed38277000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fed390e0000)
	libattr.so.1 => /lib64/libattr.so.1 (0x00007fed38072000)
	libpthread.so.0 => /lib64/libpthread.so.0 (0x00007fed37e56000)
```

### 如何制作库？

库本身就是二进制文件，我们如何知道一个库给我们提供了哪些方法？

一套完整的库文件：

1. 库文件本身
2. 头文件。**文本的，会说明库中暴露出来的方法的基本使用**
3. 说明文档

-------

我们在C/C++中写代码，有的时候会将声明放在.h文件中，定义放在.c/cpp文件中，这样做是为什么？==因为要制作库！==1. 方便使用 2. 私密



**常规的编译**

```shell
[AKANG@VM-8-9-centos 416]$ touch mytest.c
[AKANG@VM-8-9-centos 416]$ ls
lib  mytest.c  other
[AKANG@VM-8-9-centos 416]$ vim mytest.c
[AKANG@VM-8-9-centos 416]$ gcc mytest.c
/tmp/ccJHaWkh.o: In function `main':
mytest.c:(.text+0x21): undefined reference to `my_add'
mytest.c:(.text+0x33): undefined reference to `my_sub'
[AKANG@VM-8-9-centos 416]$ gcc mytest.c lib/sub.c lib/add.c
[AKANG@VM-8-9-centos 416]$ ./a.out
+ : 30
- : -10
```

**通过Makefile编译**

```shell
[AKANG@VM-8-9-centos 416]$ ls
add.o  a.out  lib  Makefile  mytest  mytest.c  mytest.o  other  sub.o
[AKANG@VM-8-9-centos 416]$ ./a.out
+ : 30
- : -10
[AKANG@VM-8-9-centos 416]$ ./mytest
+ : 30
- : -10
[AKANG@VM-8-9-centos 416]$ cat Makefile
obj=mytest.o add.o sub.o

mytest:$(obj)
	gcc -o $@ $^
%.o:%.c ./lib/%.c
	gcc -c $<

%.o:./lib/%.c
	gcc -c $<

.PHONY:clean
clean:
	rm -f *.o mytest
```

**上面很麻烦，打包成静态库**

#### 制作静态库

```shell
[AKANG@VM-8-9-centos lib]$ ls
add.c  add.h  add.o  libmymath.a  Makefile  sub.c  sub.h  sub.o
[AKANG@VM-8-9-centos lib]$ cat Makefile
libmymath.a:sub.o add.o
	ar -rc $@ $^

%.o:%.c
	gcc -c $<
```

解释：制作静态库，其实就是把所有的.o文件打包在一起

```shell
[root@localhost linux]# ls
add.c add.h main.c sub.c sub.h
[root@localhost linux]# gcc -c add.c -o add.o
[root@localhost linux]# gcc -c sub.c -o sub.o

生成静态库
[root@localhost linux]# ar -rc libmymath.a add.o sub.o
ar是gnu归档工具，rc表示(replace and create)

查看静态库中的目录列表
[root@localhost linux]# ar -tv libmymath.a
rw-r--r-- 0/0 1240 Sep 15 16:53 2017 add.o
rw-r--r-- 0/0 1240 Sep 15 16:53 2017 sub.o

t:列出静态库中的文件
v:verbose 详细信息

[root@localhost linux]# gcc main.c -L. -lmymath
-L 指定库路径
-l 指定库名
测试目标文件生成后，静态库删掉，程序照样可以运行
```

**打包+发布库的Makefile**

```c
[AKANG@VM-8-9-centos lib]$ cat Makefile
libmymath.a:sub.o add.o   
	ar -rc $@ $^

%.o:%.c
	gcc -c $<

.PHONY:clean
clean:
	rm -rf *.o libmymath.a output

.PHONY:output
output:
	mkdir output 
	cp -rf *.h output 
	cp libmymath.a output 
```

**解释：**

1. 第2行代码：我们需要将这些.o文件打包到Libmymath.a，因此让他依赖于这些.o文件，``ar -rc $@ $^``这行命令的含义参考上一段代码
2. 第5行代码：如果上面要打包的.o文件还没有被生成，那么就需要使用所有的.c文件编译成.o文件，因此让.o全部依赖.o（%就是之所有的这种类型的文件）
3. 第12行代码：发布库，创建一个output，

**别人使用库的方法**

```shell
[AKANG@VM-8-9-centos mymath]$ touch test.c
[AKANG@VM-8-9-centos mymath]$ ls
add.h  libmymath.a  sub.h  test.c
[AKANG@VM-8-9-centos mymath]$ vim test.c
[AKANG@VM-8-9-centos mymath]$ vim test.c
[AKANG@VM-8-9-centos mymath]$ gcc test.c
/tmp/cctoFLgy.o: In function `main':
test.c:(.text+0x21): undefined reference to `my_sub'
test.c:(.text+0x33): undefined reference to `my_add'
collect2: error: ld returned 1 exit status
[AKANG@VM-8-9-centos mymath]$ gcc test.c -I./ -L./ -lmymath
[AKANG@VM-8-9-centos mymath]$ ls
add.h  a.out  libmymath.a  sub.h  test.c
[AKANG@VM-8-9-centos mymath]$ ./a.out
- : -10
+ : 30
```

**代码解释：**`gcc test.c -I./ -L./ -lmymath`

**在编译的时候**

1. 首先告诉gcc `-I./`在指定的目录下寻找头文件；
2. 然后告诉gcc`-L./`在指定目录下链接库；
3. 最后告诉gcc`-lmymath`要链接的库，注意写库名字的时候要去掉前缀和后缀。

其他人使用自己写的库的Makefile

```shell
[AKANG@VM-8-9-centos mymath]$ cat Makefile
test:test.c
	gcc -o $@ $^ -I./ -L./ -lmymath
.PHONY:clean
clean:
	rm -f test
```

------

#### 制作动态库

```shell
[AKANG@VM-8-9-centos mymath2]$ ls
add.h  libmymath.so  Makefile  mytest  sub.h  test.c
[AKANG@VM-8-9-centos mymath2]$ cat Makefile
mytest:test.c
	gcc -o $@ $^ -I./ -L./ -lmymath
.PHONY:clean
clean:
	rm -f mytest
[AKANG@VM-8-9-centos mymath2]$ cat test.c
#include"add.h"
#include"sub.h"

int main()
{
    int x = 10;
    int y = 20;
    int r1 = my_sub(x, y);
    int r2 = my_add(x, y);

    printf("- : %d\n", r1);
    printf("+ : %d\n", r2);

    return 0;
}
[AKANG@VM-8-9-centos mymath2]$ ./mytest
- : -10
+ : 30
```

**解释：**制作动态库其实绝大多数步骤跟静态库是一样的，动态库与静态库的区别在于，动态库编译时的Makefile告诉了gcc我的库在哪，因此编译通过，然后在运行的时候又会出现找不到库的情况，我上面是把动态库直接和测试文件放在了一个目录下，因此没有出现问题，但是通常是不会放在一个目录下的，这时后就需要配置环境变量来确保可以找到库。

#### 制作库的流程

1. 可以先把自己的所有源文件编译成为.o
2. 制作动静态库的本质：就是将所有的.o打包。使用ar或者gcc进行打包
3. 交付：include + .a OR .so文件

**相关指令**

静态库：ar -rc

动态库：gcc -fFIC -shared



==好难，并没有很会==

## Lesson 6 进程间通信

**（Inter-Process Communication，IPC）进程间通信**

### 为什么要通信？通信的宏观原理

1. 进程之间会存在协同工作的场景，一个进程要把自己的数据交付给另一个进程，让其进行处理，这时就要进程间通信。
2. 因为进程具有独立性，交互数据的成本一定很高！两个进程要通信，必须得先看到一份公共的资源，这个资源就是指：一段内存！
3. 这份公共资源属于操作系统，虽然一个进程看不见另一个进程的资源，但是通过操作系统提供的公共资源可以实现交互。
4. 操作系统提供的这段内存，可能是以文件的方式提供，也可能是以队列的方式，也可能就是原始的内存块，这也是通信方式很多的原因

### 管道 -- 基于文件的进程通信

进程间基于文件完成通信的方法叫管道。管道是一个只能单向通信的通道，管道是**面向字节流的**

#### 匿名管道

**一段子进程写入，父进程读取的代码**

```c++
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<string.h>


int main()
{
    int pipefd[2] = {0};
    if (pipe(pipefd) != 0)
    {
        perror("pipe error！");
        return 1;
    }

    // pipefd[0] pipefd[1] 哪一个是读，哪一个是写呢？
    // 0（嘴）:读取端  1（笔）:写入端
    printf("pipefd[0]: %d\n", pipefd[0]); // 3 从3开始，0、1、2已经被分配了
    printf("pipefd[1]: %d\n", pipefd[1]); // 4


    // 父进程读取，子进程写入
    if (fork() == 0)
    {
        // 子进程
        close(pipefd[0]);


        const char* msg = "hello world";
        while (1)
        {
            write(pipefd[1], msg, strlen(msg));
            sleep(1);
        }
        
    }
    // 父进程
    close(pipefd[1]);

    while (1)
    {

        char buffer[64] = {0};
        size_t s = read(pipefd[0], buffer, sizeof(buffer)); // 如果read的返回值是0，意味着子进程关闭了文件描述符
        if (s == 0)
        {
            break;
        }
        else if (s > 0)
        {
            buffer[s] = 0;
            printf("child say to father# %s\n", buffer);
            // 没有让父进程sleep
        }
        else
        {
            break;
        }
    }

    return 0;
}
```

当往管道中写满64kb的时候，writer就不再写入了，为什么？ 因为管道有大小。但是我可以覆盖之前的内容继续写啊，干嘛不写？因为要让reader来读取。不继续写的本质是：等对方来读！

**举例：子进程往管道中写入，父进程先睡眠10s，这期间子进程会将管道写满64kb然后停止写入，10秒后父进程会读取管道中的一部分数据，读完后子进程又会继续往管道中写入。。。如此往复**

管道自带同步机制

```c++
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<string.h>


int main()
{
    int pipefd[2] = {0};
    if (pipe(pipefd) != 0)
    {
        perror("pipe error！");
        return 1;
    }

    // pipefd[0] pipefd[1] 哪一个是读，哪一个是写呢？
    // 0（嘴）:读取端  1（笔）:写入端
    printf("pipefd[0]: %d\n", pipefd[0]); // 3 从3开始，0、1、2已经被分配了
    printf("pipefd[1]: %d\n", pipefd[1]); // 4


    // 父进程读取，子进程写入
    if (fork() == 0)
    {
        // 子进程
        close(pipefd[0]);
        
        // 持续往pipe中写入
        int count = 0;
        while (1)
        {
            write(pipefd[1], "a", 1);
            count++;
            printf("count: %d\n", count);
        }

        exit(0);
        
    }
    // 父进程
    close(pipefd[1]);

    while (1)
    {
        sleep(10); // 先让父进程睡眠10s,让子进程把管道写满，写满之后就不再写入
        char c[1024*4+1] = {0}; // 睡眠10s后读取，读取一定的数据量后子进程又会继续往管道中写入
        size_t s = read(pipefd[0], c, sizeof(c));
        c[s] = 0;

    }

    return 0;
}
```

**管道读写的四种情况**

1. 读端不读或者读的慢，写端要等读端
2. 读端关闭，写端受到SIGPIPE信号直接终止
3. 写端不写或者写的慢，读端要等写端
4. 写端关闭，读端读完pipe内部的数据然后再读，会读到0，表明读到文件尾
5. 管道的声明周期是随进程的，管道也是文件，进程退出的时候OS会自动关闭管道



> 进程具有独立性->进程通信的成本其实比较高->必须先解决一个问题->让不同的进程先要看到同一份资源（内存文件、内存、队列）[一定需要OS来提供]->pipe本质：是通过子进程继承父进程资源的特性，达到一个让不同进程看到同一份资源！
>

- 管道应用的一个限制就是只能在具有共同祖先（具有亲缘关系）的进程间通信。
- 如果我们想在不相关的进程之间交换数据，可以使用FIFO文件来做这项工作，它经常被称为**命名管道**。
- 命名管道是一种特殊类型的文件
- 命名管道的数据不会刷新到磁盘

#### mkfifo

```shell
NAME
       mkfifo - make a FIFO special file (a named pipe)

SYNOPSIS
       #include <sys/types.h>
       #include <sys/stat.h>

       int mkfifo(const char *pathname, mode_t mode);

DESCRIPTION
       mkfifo()  makes  a  FIFO  special file with name pathname.  mode specifies the FIFO's permissions.  It is modified by the process's umask in the
       usual way: the permissions of the created file are (mode & ~umask).

       A FIFO special file is similar to a pipe, except that it is created in a different way.  Instead of being an anonymous communications channel, a
       FIFO special file is entered into the file system by calling mkfifo().

       Once  you  have  created  a  FIFO special file in this way, any process can open it for reading or writing, in the same way as an ordinary file.
       However, it has to be open at both ends simultaneously before you can proceed to do any input or output operations on it.  Opening  a  FIFO  for
       reading  normally blocks until some other process opens the same FIFO for writing, and vice versa.  See fifo(7) for nonblocking handling of FIFO
       special files.

RETURN VALUE
       On success mkfifo() returns 0.  In the case of an error, -1 is returned (in which case, errno is set appropriately).
```

**创建一个命名管道**

```c++
#include<stdio.h>
#include<sys/stat.h>
#include<sys/types.h>

#define MY_FIFO "./fifo"

int main()
{
    umask(0); // 这个函数可以将当前程序中文件的掩码设置为0，而不影响系统的掩码
    if (mkfifo(MY_FIFO, 0666) < 0)
    {
        perror("mkfifo");
        return 1;
    }

    return 0;
}
```

因为命名管道也是基于字节流的，所以实际上，信息传递的时候是需要双方定制“协议的”，学到网络再考虑。

#### 父子进程之间使用fifo通信的例子

**描述：**server.c是主进程，其中创建一个fifo，主进程负责读取命名管道中的数据然后打印出来，客户进程是client.c，负责往管道中输入数据，当两个进程都跑起来的时候，就实现了进程之间的通信。

**注意：**命名管道是一个文件，两进程是通过文件名来寻找命名管道的

`server.c`

```c++
#include<stdio.h>
#include<sys/stat.h>
#include<sys/types.h>
#include<fcntl.h>
#include<unistd.h>
#include<string.h>
#include<sys/wait.h>
#include<stdlib.h>


#define MY_FIFO "./fifo"

int main()
{
    umask(0); // 这个函数可以将当前程序中文件的掩码设置为0，而不影响系统的掩码
    if (mkfifo(MY_FIFO, 0666) < 0)
    {
        perror("mkfifo");
        return 1;
    }

    // 只需文件操作即可
    int fd = open(MY_FIFO, O_RDONLY);
    if(fd < 0)
    {
        perror("open");
        return 2;
    }

    // 业务逻辑，可以进行对应的读写了
    while (1)
    {
        char buffer[64] = {0};
        ssize_t s = read(fd, buffer, sizeof(buffer) - 1);
        if (s > 0)
        {
            // sucess
            buffer[s] = 0;
            if (strcmp(buffer, "show") == 0)
            {
                if (fork() == 0)
                {
                    execl("/usr/bin/ls", "ls", "-l", NULL);
                    exit(1);
                }

                waitpid(-1, NULL, 0);
            }
            else if (strcmp(buffer, "run") == 0)
            {
                if (fork() == 0)
                {
                    execl("/usr/bin/sl", "sl", NULL);
                }
                waitpid(-1, NULL, 0);
            }
            else
            {
                printf("client# %s\n", buffer);
            }
        }
        else if (s == 0)
        {
            //peer close 
            printf("client quit ... \n");
            break;
            
        }
        else 
        {
            // error 
            perror("read");
            break;
        }
    }
    close(fd);

    return 0;
}
```

`client.c`

```c++
#include"common.h" // 此时是不是两个程序，又能看到同一个资源的能力
#include<string.h>
int main()
{
    // 用不用再创建fifo？？ 不用，我只需要获取就行
    int fd = open(MY_FIFO, O_WRONLY); 
    if (fd < 0)
    {
        perror("open");
        return 1;
    }

    // 业务逻辑
    while (1)
    {
        printf("请输入# ");
        fflush(stdout);
        char buffer[64] = {0};
        // 先把数据从标准输入拿到我们的client进程内部
        ssize_t s = read(0, buffer, sizeof(buffer)-1);
        if (s > 0)
        {
            buffer[s-1] = 0;
            printf("%s\n", buffer);
            // 拿到了数据
            write(fd, buffer, strlen(buffer));
        }
    }

    close(fd);
    return 0;
}
```

#### 匿名管道和命名管道区别

为什么我们之前的pipe叫匿名管道？为什么现在的fifo叫做命名管道呢？

1. 因为pipe文件没有名字，它是通过父子继承的方式看到同一份资源，因此不需要文件名字
2. 而fifo文件有名字，为了保证不同的进程看到同一份文件，因此需要名字

### system V IPC共享内存

> 在同一主机内的通信间通信方案叫做**system V**方案！

**system V**

1. 共享内存
2. 消息队列
3. 信号量

#### 共享内存

1. 通过某种调用，在内存中创建一份内存空间
2. 通过某种调用，让进程“挂接”到这份新开辟的内存空间

<img src=".\Image\image-20230331111936663.png" alt="image-20230331111936663" style="zoom:50%;" />

**思考**

1. OS内可不可能存在多个进程，同时使用不同的共享内存来进行进程间的通信？？

   共享内存在系统中可能存在多份，操作系统需要管理这些共享内存，先描述、再组织

2. 你怎么保证两个或多个进程，看到的是同一个共享内存呢？

   共享内存一定要有一个标识唯一性的ID，方便让不同的进程能识别同一个共享内存资源

3. 共享内存的ID在哪里？

   存在描述共享内存的数据结构中

#### 相关接口

##### shmget

```c++
 int shmget(key_t key, size_t size, int shmflg);
```

> **功能**：用来创建共享内存
> **原型**：int shmget(key_t key, size_t size, int shmflg);
> **参数**：
> 			key:这个共享内存段名字
>
> ​			size:共享内存大小，size建议是4KB的整数倍（共享内存在内核中申请的基本单位是页，内存页（4KB），申请方式是向上取整，但不会给用户多余的空间）
>
> ​			shmflg:由九个权限标志构成，它们的用法和创建文件时使用的mode模式标志是一样的
> **返回值**：成功返回一个非负整数，即该共享内存段的标识码；失败返回-1  

<img src=".\Image\image-20230331151637623.png" alt="image-20230331151637623" style="zoom: 50%;" />

关于shmflg参数

- 如果单独使用IPC_CREAT，或者flag为0：创建一个共享内存，如果创建的共享内存已经存在，则直接返回当前已经存在的共享内存。
- IPC_CREAT | IPC_EXCL：如果不存在共享内存，则创建之。如果已经有了共享内存，则返回出错！（意义：如果我调用成功，得到的一定是一个最新的，没有别人使用的共享内存）

注意：共享内存被创建之后它的生命周期是随内核的，不会因为进程结束而被释放，因此需要专门释放。

![image-20230331162622323](.\Image\image-20230331162622323.png)

##### shmat

> **功能**：将共享内存段连接到进程地址空间
> **原型**：
> 			void *shmat(int shmid, const void *shmaddr, int shmflg);
> **参数**：
> 			shmid: 共享内存标识
> 			shmaddr:指定连接的地址++
> 			shmflg:它的两个可能取值是SHM_RND和SHM_RDONLY
> **返回值**：成功返回一个指针，指向共享内存第一个节；失败返回-1  

##### shmdt

> **功能**：将共享内存段与当前进程脱离
> **原型**：
> 			int shmdt(const void *shmaddr);
> **参数**：
> 			shmaddr: 由shmat所返回的指针
> **返回值**：成功返回0；失败返回-1
> **注意**：将共享内存段与当前进程脱离不等于删除共享内存段  

##### shmctl 

> **功能**：用于控制共享内存
> **原型**：
> 			int shmctl(int shmid, int cmd, struct shmid_ds *buf);
> **参数**：
> 			shmid:由shmget返回的共享内存标识码
> 			cmd:将要采取的动作（有三个可取值）
> 			buf:指向一个保存着共享内存的模式状态和访问权限的数据结构
> **返回值**：成功返回0；失败返回-1  

-----

##### ==代码举例演示==

`comm.h`

```c++
#pragma once 

#include<stdio.h>
#include<sys/ipc.h>
#include<sys/shm.h>

#define PATH_NAME "./"
#define PROJ_ID 0x6666
#define SIZE 4097
```

`server.c`

```c++
#include "comm.h"
#include <unistd.h>

int main()
{
    key_t key = ftok(PATH_NAME, PROJ_ID);
    if(key < 0){
        perror("ftok");
        return 1;
    }

    int shmid = shmget(key, SIZE, IPC_CREAT|IPC_EXCL|0666); //创建全新的shm，如果和系统已经存在ID冲突，我们出错返回
    if(shmid < 0){
        perror("shmget");
        return 2;
    }

    printf("key: %u, shmid: %d\n", key, shmid);
    sleep(1);

    char* mem = (char*)shmat(shmid, NULL, 0); // 将共享内存映射进mem地址空间
    printf("attaches shm success\n");
    //sleep(15);
    
    // 这里就是我们后面要进行的通信逻辑
    while (1)
    {
        sleep(1);
        printf("%s\n", mem); // server认为共享内存里面放的是一个长字符串
    }
    

    shmdt(mem);

    printf("detaches shm success\n");
    //sleep(5);

    shmctl(shmid, IPC_RMID, NULL);
    printf("key: 0x%x, shmid: %d -> shm delete success\n", key, shmid);

    sleep(10);

    return 0;
}
```

`client.c`

```
#include "comm.h"
#include <unistd.h>

int main()
{
    key_t key = ftok(PATH_NAME, PROJ_ID);
    if(key < 0){
        perror("ftok");
        return 1;
    }

    printf("%u\n", key);
    

    // client这里只需要进行获取即可
    int shmid = shmget(key, SIZE, IPC_CREAT);
    if(shmid < 0)
    {
        perror("shmget");
        return 1;
    }

    char* mem = (char*)shmat(shmid, NULL, 0);
    //sleep(5);
    printf("client process attaches success!\n");

    // 这个地方就是我们要通信的区域
    char c = 'A';
    while (c <= 'Z')
    {
        mem[c-'A'] = c;
        c++;
        mem[c-'A'] = 0; // 0是空格
        sleep(2);
    }


    shmdt(mem);
    //sleep(5);
    printf("client process detaches success\n");
    // client要不要删除？？不需要，因为是另一个继承创建的

    return 0;
}
```

------

##### 共享内存的特征

1. 共享内存一旦建立好并映射进自己的进程地址空间，该进程就可以直接看到该共享内存，就如同malloc的空间一般，不需要任何系统调用接口
2. 共享内存不提供任何同步或者互斥机制，需要程序员自行保证数据安全
3. read和write的本质：将数据从内核拷贝到用户或者从用户拷贝到内核，而共享内存直接就是将一块内存映射给一些进程，让这些进程自由读取这块内存上的信息

##### 删除ipc资源

有的时候进程还没到删除ipc资源的那一行我就结束进程了，然而共享内存并不会随着进程结束而被释放（生命周期随着内核），因此需要手动释放

```shell
# ./server
shmget: File exists
# ipcs -m
------ Shared Memory Segments --------
key shmid owner perms bytes nattch status
0x66026a25 688145 root 666 4096 0
# ipcrm -m 688145 #删除shm ipc资源，注意，不是必须通过手动来删除，这里只为演示相关指令，删除IPC资源是进程该做的事情
```

##### **什么是信号量？**

管道，匿名or命名，共享内存，消息队列：都是以传输数据为目的的！信号量不是以传输数据为目的的！通过共享“资源”的方式，来达到多个进程的同步和互斥的目的。**信号量的本质：是一个计数器，类似 int count; 衡量临界资源中资源数目的（类似电影院100张票，count就是记录卖了多少张票）**

1. 什么是**临界资源**？

   凡是被多个执行流同时能够访问的资源就是临界资源！同时向显示器打印。进程间通信的时候，管道，共享内存，消息队列等都是临界资源。

2. 什么是**临界区**？

   进程的代码可是有很多的，其中用来访问临界资源的代码，就叫临界区

3. 什么是**原子性**？

   一件事要么不做，要么做就做完，没有中间态，就叫原子性

4. 什么是**互斥**？

   在任意一个时刻，只能允许一个执行流进入临界资源，执行他自己的临界区

## Lesson 7 进程信号

强调：进程信号和信号量没有任何关系，类似老婆和老婆饼。

1. 进程具有识别信号并处理信号的能力，而且该能力是远远早于信号的产生的
2. 进程收到某种信号的时候，并不是立即处理的，而是在合适的时候
3. 进程收到信号之后，需要先将信号保存起来，以供在合适的时候处理
4. 信号的本质也是数据。信号的发送->往进程task_struct内写入信号数据
5. 无论我们的信号怎么发送，本质都是在底层通过OS发送的

### 杀进程的方式

**杀前台进程**：`按ctrl c`

**杀后台进程**：`kill -9 进程号`所以进程号怎么获得呢？`ps axj | grep mytest`

### 信号捕捉

**函数声明**

```c++
#include <signal.h>
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
```

**参数说明**

第一个参数signum：指明了所要处理的信号类型，它可以取除了SIGKILL和SIGSTOP外的任何一种信号。 　 
第二个参数handler：描述了与信号关联的动作，它可以取以下三种值： 

1. SIG_IGN

   这个符号表示忽略该信号。 

   ```c++
   #include <stdio.h>
   #include <signal.h>
   int main(int argc, char *argv[])
   {
       signal(SIGINT, SIG_IGN);
       while(1);
       return 0;
   }
   ```

   SIGINT信号代表由InterruptKey产生，通常是CTRL +C 或者是DELETE 。执行上述代码时，按下CTRL + C程序没有反应。这就对了，如果我们想结束该程序可以按下CTRL +\来结束，当我们按下CTRL +\组合键时，产生了SIGQUIT信号，此信号并没有被忽略。

2. SIG_DFL 　

   这个符号表示恢复对信号的系统默认处理。不写此处理函数默认也是执行系统默认操作。 

   ```c++
   #include <stdio.h>
   #include <signal.h>
   int main(int argc, char *argv[]) 
   {
       signal(SIGINT, SIG_DFL);
       while(1);
       return 0;
   }
   ```

   这时就可以按下CTRL +C 来终止该进程了。把signal(SIGINT, SIG_DFL);这句去掉，效果是一样的。

3. sighandler_t类型的函数指针 

   此函数必须在signal()被调用前申明，handler中为这个函数的名字。当接收到一个类型为sig的信号时，就执行handler 所指定的函数。（int）signum是传递给它的唯一参数。执行了signal()调用后，进程只要接收到类型为sig的信号，不管其正在执行程序的哪一部分，就立即执行func()函数。当func()函数执行结束后，控制权返回进程被中断的那一点继续执行。 

   ```c++
   #include<stdio.h>
   #include<unistd.h>
   #include<signal.h>
   #include<stdlib.h>
   
   
   void handler(int signo)
   {
       switch (signo)
       {
           case 2:
               printf("hello world,get a signal: %d\n", signo);
               break; 
           case 3:
               printf("hello Quan, get a signal: %d\n", signo);
               break;
           case 9:
               printf("hello ..... get a signal: %d\n", signo);
               break;
           default:
               break;
   
       }
      // exit(1);
   
   }
   
   int main()
   {
       int sig = 1;
       for (; sig <= 31; sig++)
       {
           signal(sig, handler);
       }
   
       while (1)
       {
           printf("hello world!\n");
           sleep(1);
       }
   
       return 0;
   }
   ```

   该程序运行后需要使用 kill -9来杀死进程，因为9号信号不可被捕捉，不会影响执行

### 对信号的处理操作

1. 忽略此信号。
2. 执行该信号的默认处理动作。
3. 提供一个信号处理函数,要求内核在处理该信号时切换到用户态执行这个处理函数,这种方式称为捕捉(Catch)一个信号  

### 信号产生的方式

1. **键盘产生**：ctrl c ，ctrl v等等

2. **程序中存在异常问题，导致我们收到信号退出**。软件上面的错误，通常会体现在硬件（CPU除以0）或者其它软件上

   **Core Dump**：首先解释什么是Core Dump。当一个进程要异常终止时,可以选择把进程的用户空间内存数据全部 保存到磁盘上,文件名通常是core,这叫做Core Dump。进程异常终止通常是因为有Bug,比如非法内存访问导致段错误,事后可以用调试器检查core文件以查清错误原因,这叫做Post-mortem Debug（事后调试）。一个进程允许产生多大的core文件取决于进程的Resource Limit(这个信息保存 在PCB中)。默认是不允许产生core文件的,因为core文件中可能包含用户密码等敏感信息,不安全。  

3. **通过系统调用产生信号**

   模拟实现kill命令

   ```c++
   #include<stdio.h>
   #include<unistd.h>
   #include<signal.h>
   #include<stdlib.h>
   #include<sys/types.h>
   #include<sys/wait.h>
   
   static void Usage(const char* proc)
   {
       printf("Usage:\n\t %s signo who\n", proc);
   }
   
   int main(int argc, char* argv[]) // 程序运行时获取输入，以字符串类型存在argv[]数组中，argc为参数个数
   {
       if (argc != 3)
       {
           Usage(argv[0]);
           return 1;
       }
   
       int signo = atoi(argv[1]); 
       int who = atoi(argv[2]);
   
       kill(who, signo); // 系统接口
   
       printf("signo: %d, who: %d\n", signo, who);
   
       return 0;
   }
   ```

4. 软件条件也能产生信号

   通过某种软件（OS）来触发信号的发送，系统层面设置定时器，或者某种操作而导致条件不就绪等这样的场景下，触发信号的发送。

   举例：

   ```
   #include <unistd.h>
   unsigned int alarm(unsigned int seconds);
   调用alarm函数可以设定一个闹钟,也就是告诉内核在seconds秒之后给当前进程发SIGALRM信号, 该信号的默认处理动作是终止当前进程。
   ```

   使用这个函数来计算一下1秒钟我们的服务器可以累加多少次

   ```c++
   #include <stdio.h>
   #include <stdlib.h>
   #include <unistd.h>
   #include <signal.h>
   #include <sys/types.h>
   #include <sys/wait.h>
   
   int count = 0;
   
   void HandlerAlarm(int signo)
   {
       printf("hello: %d\n", count);
   
       exit(1);
   }
   
   
   //统计一下，1s，我们的server能够对int递增到多少
   int main()
   {
       signal(SIGALRM, HandlerAlarm);
       alarm(1); //没有设置alarm信号的捕捉动作(没有自定义)，执行默认动作，终止进程
   
       while(1){
           count++;
           //为何在这里比较慢？？因为有IO
           //printf("hello : %d\n", count++);
       }
   }
   ```

   需要注意：有IO的时候累加到了20多万，没有IO纯累加可以到接近5亿，因此当进程中有很多IO的时候需要考虑效率问题。

**总结：产生信号的方式千差万别，但是最终都是通过OS向目标发送信号的**

### 阻塞信号

#### 相关概念

- 实际执行信号的处理动作称为**信号递达**(Delivery)
- 信号从产生到递达之间的状态,称为**信号未决**(Pending)。
- 进程可以选择阻塞 (Block )某个信号。
- 被阻塞的信号产生时将保持在未决状态,直到进程解除对此信号的阻塞,才执行递达的动作.
- 注意,阻塞和忽略是不同的,只要信号被阻塞就不会递达,而忽略是在递达之后可选的一种处理动作  

OS发送信号的本质：修改目标进程的pending位图

**pending**：保存的是已经收到但是还没有被递达的信号

**block**：状态位图（信号屏蔽字），表示那些信号不应该被递达，直到接触阻塞

**handler**：函数指针数组，每个信号的编号就是该数组的下标

<img src=".\Image\image-20230407100322336.png" alt="image-20230407100322336" style="zoom:50%;" />

#### 信号集操作函数

sigset_t类型对于每种信号用一个bit表示“有效”或“无效”状态,至于这个类型内部如何存储这些bit则依赖于系统实现,从使用者的角度是不必关心的,使用者只能调用以下函数来操作sigset_ t变量,而不应该对它的内部数据做任何解释,比如用printf直接打印sigset_t变量是没有意义

```c
#include <signal.h>
int sigemptyset(sigset_t* set); // 初始化set所指向的信号集,使其中所有信号的对应bit清零,表示该信号集不包含任何有效信号
int sigfillset(sigset_t* set); // 初始化set所指向的信号集,使其中所有信号的对应bit置位,表示该信号集的有效信号包括系统支持的所有信号
int sigaddset (sigset_t* set, int signo);
int sigdelset(sigset_t* set, int signo);
int sigismember(const sigset_t* set, int signo);  
```

- 函数sigemptyset初始化set所指向的信号集,使其中所有信号的对应bit清零,表示该信号集不包含 任何有效信号。
- 函数sigfillset初始化set所指向的信号集,使其中所有信号的对应bit置位,表示 该信号集的有效信号包括系统支持的所有信号。
- 注意,在使用sigset_ t类型的变量之前,一定要调 用sigemptyset或sigfillset做初始化,使信号集处于确定的状态。初始化sigset_t变量之后就可以在调用**sigaddset**和**sigdelset**在该信号集中添加或删除某种有效信号

##### sigprocmask  

调用函数sigprocmask可以读取或更改进程的信号屏蔽字(阻塞信号集) 

```c
#include <signal.h>
int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
返回值:若成功则为0,若出错则为-1
```

如果oset是非空指针,则读取进程的当前信号屏蔽字通过oset参数传出。如果set是非空指针,则 更改进程的信号屏蔽字,参数how指示如何更改。如果oset和set都是非空指针,则先将原来的信号 屏蔽字备份到oset里,然后根据set和how参数更改信号屏蔽字。假设当前的信号屏蔽字为mask,下表说明了how参数的可选值  

```c++
void show_pending(sigset_t *set)
{
    printf("curr process pending: ");
    for(int i = 1; i <= 31; i++){
        if(sigismember(set, i)){
            printf("1");
        }
        else{
            printf("0");
        }
    }

    printf("\n");
}
```

==演示==

```c
#include<stdio.h>
#include<unistd.h>
#include<signal.h>
#include<string.h>

void show_pending(sigset_t *set)
{
    printf("curr process pending: ");
    int i = 0;
    for(i = 1; i <= 31; i++)
    {
        if(sigismember(set, i))
        {
            printf("1");
        }
        else
        {
            printf("0");
        }
    }

    printf("\n");
}

void handler(int signo)
{
    printf("2号信号被递达了，已经处理完成！\n");
}

int main()
{
    signal(2, handler); // 捕捉2号信号，如果检测到2号信号的输入就执行handler函数
    
    sigset_t iset, oset;
    sigemptyset(&iset); // iset是一个32位的位图，我们手动不能改，用这个函数来将每个位置为零
    sigemptyset(&oset);

    sigaddset(&iset, 2); // 给信号2对应的比特位置位1
    
    // 1. 设置当前进程的屏蔽字
    // 2. 获取当前进程老的屏蔽字
    sigprocmask(SIG_SETMASK, &iset, &oset); // 将信号屏蔽字加入到掩码中
   

    int count = 0;
    sigset_t pending;

    while (1)
    {
        sigemptyset(&pending);
        sigpending(&pending); // 读取当前进程中已经收到但是没有递达的信号
        show_pending(&pending);
        sleep(1);

        count++;

        if (count == 10)
        {
           sigprocmask(SIG_SETMASK, &oset, NULL);
           printf("恢复对2号信号，可以被递达了\n");
        }
    }
    return 0;
}
```

所谓的系统调用，就是进程的身份转化成为内核，然后根据内核页表找到系统函数，执行就行了

#### 信号处理的完全过程

<img src=".\Image\image-20230407204006487.png" alt="image-20230407204006487" style="zoom:80%;" />

### 可重入函数

可重入函数主要用于多任务环境中，一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统资源，比如[全局变量](https://baike.baidu.com/item/全局变量/4725296?fromModule=lemma_inlink)区，[中断向量表](https://baike.baidu.com/item/中断向量表/4947137?fromModule=lemma_inlink)等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。

如果一个函数符合以下条件之一则是不可重入的：

- 调用了malloc或free，因为malloc也是用全局链表来管理堆的
- 调用了标准I/O库函数。标准I/O库的很多实现都以不可重入的方式使用全局数据结构

### volatile关键字

> **volatile关键字的作用：**告诉编译器，不要对我这个变量做任何优化，读取时必须贯穿式的读取内存，不要读取中间缓冲区寄存区中的数据！

```c
#include<stdio.h>
#include<signal.h>

volatile int flag = 0;

void handler(int signo)
{
    flag = 1;
    printf("change flag o to 1\n");
}

int main()
{
    signal(2, handler);

    while (!flag); // 正常情况下：程序在这卡住，我们输2号信号，让进程执行handler，将flag改为1，然后结束后就可以执行下面的代码了
    // 但是，如果我们编译器对代码的优化级别提高了之后，编译器一看main函数中对这个flag没有进行任何操作，所以会把flag加载到寄存器中,以此来提高执行速度
    // 然后内存中的flag虽然在handler中被修改了，但是while里面的（从寄存器读取）却不会改变，这样我们的程序就不能按照我们的意图进行了
    // 为什么会这样？因为在编译器看来，我们对flag并没有做任何操作，这个主要是因为main函数中未做任何操作
    // 解决办法就是给flag加上volatile关键字
    // volatile关键字的作用：告诉编译器，不要对我这个变量做任何优化，读取时必须贯穿式的读取内存，不要读取中间缓冲区寄存区中的数据！

    printf("这个进程是正常退出的！\n");

    return 0;
}
```

### SIGCHLD信号

**SIGCHLD的产生条件：**

- 子进程终止
- 子进程接收到SIGSTOP信号停止时
- 子进程处于停止状态，接收到SIGCONT后唤醒

注意：通过signal(SIGCHLD, SIG_IGN)通知内核对子进程的结束不关心，由内核回收。如果不想让父进程挂起，可以在父进程中加入一条语句：signal(SIGCHLD,SIG_IGN);表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>

void GetChild(int signo)
{
    //waitpid();
    printf("get a signal : %d, pid: %d\n", signo, getpid());
}

int main()
{
    //signal(SIGCHLD, GetChild); // 使用这行代码可以得到子进程id，然后查看其状态，可以发现子进程退出后状态变为了Z+,即僵尸进程
    //显示设置忽略17号信号，当进程退出后，自动释放僵尸进程
    //只在Linux下有效
    signal(SIGCHLD, SIG_IGN);  // 使用这行代码子进程退出后忽略SIGCHLD，于是内核自动释放他
    pid_t id = fork();
    if(id == 0){
        //child
        int cnt = 5;
        while(cnt){
            printf("我是子进程: %d\n", getpid());
            sleep(1);
            cnt--;
        }
        exit(0);
    }

    while(1);
    return 0;
}
```

## Lesson 8 多线程

### 什么是线程？

一般教材中这样说：线程是在进程==内部==运行的一个==执行分支==（执行流），属于==进程==的一部分，粒度要比进程更加细和轻量化。

- ==内部==：线程在进程的地址空间内运行

- ==执行分支==：CPU调度的时候只看PCB，每一个PCB曾经被指派过指向方法和数据，CPU可以直接调度

- ==进程==：之前对进程的理解：内部只有一个执行流；如今对进程的理解：内部可以有多个执行流。

  创建进程的成本非常高，成本=时间+空间。创建进程要使用的资源是非常多的，

  在**内核的视角**：进程是承担分配系统资源的基本实体，线程是CPU调度的基本单位，承担进程资源的一部分的基本实体，进程划分系统资源给线程

  Linux下的进程是小于传统意义上的进程，是轻量级进程。可以说，**Linux中没有正儿八经的线程控制块，只有用进程控制块模拟的线程**。

  因为Linux的线程是用进程模拟的，所以Linux下不会给我们直接提供操作线程的接口，而是给我们提供，在同一个地址空间内创建PCB的方法，分配资源给指定的PCB的接口。

### 数据共享

> 进程，独立性，可以有部分共享资源（管道、ipc资源）
>
> 线程，大部分资源都是共享的，可以有部分资源是“私有”的（PCB，栈，上下文）

- **进程**是**资源分配**的基本单位

- **线程**是**调度**的基本单位

- 线程共享进程数据，但也拥有自己的一部分数据:

  - 线程ID

  - 一组寄存器

  - 栈

  - errno
  - 信号屏蔽字
  - 调度优先级  

**进程的多个线程共享同一地址空间**,因此Text Segment、Data Segment都是共享的,如果定义一个函数,在各线程中都可以调用,如果定义一个全局变量,在各线程中都可以访问到,除此之外,各线程还共享以下进程资源和环境:

- 文件描述符表
- 每种信号的处理方式(SIG_ IGN、SIG_ DFL或者自定义的信号处理函数)
- 当前工作目录
- 用户id和组id  

### 进程和线程举例

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

void* thread_run(void* args)
{
    const char* id = (const char*)args;
    while (1)
    {
        printf("我是%s线程, %d\n", id, getpid());
        sleep(1);
    }
}

int main()
{
    pthread_t tid;
    pthread_create(&tid, NULL, thread_run, (void*)"thread 1");

    while(1)
    {
        printf("我是main线程， %d\n", getpid());
        sleep(1);
    }
}
```

**运行结果：**

<img src=".\Image\image-20230410105009490.png" alt="image-20230410105009490" style="zoom:50%;" />

<img src=".\Image\image-20230410105119483.png" alt="image-20230410105119483" style="zoom:80%;" />

通过运行结果可以看出，上述代码运行后产生了一个进程，这一个进程中有两个线程，这两个线程的的进程id都是一样的。

<img src=".\Image\image-20230415212152659.png" alt="image-20230415212152659" style="zoom:80%;" />

### 线程的优点

- 创建一个新线程的代价要比创建一个新进程小得多
- 与进程之间的切换相比，线程之间的切换需要操作系统做的工作要少很多
- 线程占用的资源要比进程少很多
- 能充分利用多处理器的可并行数量
- 在等待慢速I/O操作结束的同时，程序可执行其他的计算任务
- 计算密集型应用，为了能在多处理器系统上运行，将计算分解到多个线程中实现（但是不一定线程越多越好，线程过多可能会导致过度调度切换）
- I/O密集型应用，为了提高性能，将I/O操作重叠。线程可以同时等待不同的I/O操作。  

### 线程的缺点

- 性能损失

  一个很少被外部事件阻塞的计算密集型线程往往无法与其它线程共享同一个处理器。如果计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失，这里的性能损失指的是增加了额外的同步和调度开销，而可用的资源不变。

- 健壮性降低
  编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了不该共享的变量而造成不良影响的可能性是很大的，换句话说线程之间是缺乏保护的。**一个线程崩了，整个进程就会崩**

- **缺乏访问控制**
  进程是访问控制的基本粒度，在一个线程中调用某些OS函数会对整个进程造成影响。

- 编程难度提高
  编写与调试一个多线程程序比单线程程序困难得多  

### 多线程相关接口

库：pthread.h

<img src=".\Image\image-20230415220532835.png" alt="image-20230415220532835" style="zoom:50%;" />

这个库虽然系统中已经安装了，但是它并不属于操作系统，需要在编译的时候链接

#### 线程创建接口

```c
NAME
       pthread_create - create a new thread

SYNOPSIS
       #include <pthread.h>

   	   int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                      void *(*start_routine) (void *), void *arg);
DESCRIPTION
       The  pthread_create()  function starts a new thread in the calling process.  The new thread starts execution by invoking start_routine(); arg is
       passed as the sole argument of start_routine().
```

**函数解释：**

- 第一个参数thread是一个指针，指向的是一个线程在内存上的地址
- 第二个参数attr是线程的属性，目前使用的是空指针
- 第三个参数是一个函数指针，这个到时候就传想让线程执行的操作的那个函数名
- 第四个参数是上一步传入的函数的参数



**简单使用**

```c
#include<stdio.h>
#include<pthread.h>
#include<unistd.h>

void* thread_run(void* args)
{

    while (1)
    {
        printf("我是新线程[%s]，我创建的线程ID是：%lu\n", (const char*)args, pthread_self());
        sleep(1);
    }
}

int main()
{
    pthread_t tid;
    pthread_create(&tid, NULL, thread_run, (void*)"new thread");

    while (1)
    {
        printf("我是主线程，我创建的线程ID是：%lu\n", tid);
        sleep(1);
    }

    return 0;
}
```

一个线程的崩溃，会导致整个进程的崩溃。

我们的线程是由进程模拟的，因此线程也是可以等待的，**线程等待**可以用来接收线程运行结束后的返回值，通过返回值来判断线程运行结果

#### 线程等待接口

```c
NAME
       pthread_join - join with a terminated thread

SYNOPSIS
       #include <pthread.h>

       int pthread_join(pthread_t thread, void **retval);

       Compile and link with -pthread.

DESCRIPTION
       The  pthread_join()  function waits for the thread specified by thread to terminate.  If that thread has already terminated, then pthread_join()
       returns immediately.  The thread specified by thread must be joinable.

       If retval is not NULL, then pthread_join() copies the exit status of the target thread (i.e., the value  that  the  target  thread  supplied  to
       pthread_exit(3)) into the location pointed to by *retval.  If the target thread was canceled, then PTHREAD_CANCELED is placed in *retval.

       If  multiple  threads  simultaneously try to join with the same thread, the results are undefined.  If the thread calling pthread_join() is can‐
       celed, then the target thread will remain joinable (i.e., it will not be detached).

RETURN VALUE
       On success, pthread_join() returns 0; on error, it returns an error number.
```

**函数解释：**

- 第一个参数thread就是线程本身

- 第二个参数是用来接收thread执行后的返回值

  ==为什么线程的传参和返回值要使用void*类型？==

  **因为需要一个万能类型，具体传了什么和接收什么，自己强转就行。**

这个函数就是接收线程结束后的返回值，以此来判断线程运行的状态

```c
void *thread_run(void *args)
{
    pthread_detach(pthread_self()); // 线程分离
    int num = *(int*)args;
    while(1){
        printf("我是新线程[%d], 我创建的线程ID是: %lu\n", num,pthread_self());
        sleep(2);
        break;
        //pthread_cancel(g_id);
        //break;
        //野指针问题
        //if(num == 3){
        //    printf("thread number : %d quit\n", num);
        //    int *p = NULL;
        //    *p = 1000;
        //}
    }
    //exit(123);
    //pthread_exit((void*)123);
    
    // 也可以返回对象
    //obj *x = new obj; 

    //return x;
    return (void*)111;
}

#define NUM 1


int main()
{
    g_id = pthread_self();

    pthread_t tid[NUM];
    for(int i = 0; i < NUM; i++){
        pthread_create(tid+i, NULL, thread_run, (void*)&i);
        sleep(1);
    }

    printf("wait sub thread....\n");
    sleep(1);

    printf("cancel sub thread ...\n");
    // pthread_cancel(tid[0]);

    //void *,32,4.   64,8, 指针变量，本身就可以充当某种容器保存数据
    void *status = NULL;

    //退出信息，异常呢？不需要处理
    //不要认为，这里的返回值只是int，也可以是其他变量,对象的地址(不能是临时的)
    int ret = 0;
    for(int i = 0; i < NUM; i++){
        ret = pthread_join(tid[i], &status);
    }

    printf("ret: %d, status: %d\n", ret, (int)status);

    sleep(3);
   // while(1){
   //     printf("我是主线程, 我的thread ID: %lu\n", pthread_self());

   //     printf("#########################begin########################\n");
   //     for(int i = 0; i < NUM; ++i){
   //         printf("我创建的线程[%d]是: %lu\n", i, tid[i]);
   //     }
   //     printf("#########################end########################\n");
   //     sleep(1);
   // }

}
```

#### 线程终止方案

1. 函数中return

   - main函数退出return的时候代表主线程和进程的退出

   - 其他线程函数return只代表当前线程退出

2. 新线程通过pthread_exit终止自己（exit是终止进程的）

3. 取消目标线程（不建议使用）

#### 线程分离

- 默认情况下，新创建的线程是joinable的，线程退出后，需要对其进行pthread_join操作，否则无法释放资源，从而造成系统泄漏。
- 如果不关心线程的返回值，join是一种负担，这个时候，我们可以告诉系统，当线程退出时，自动释放线程资源。  

`int pthread_detach(pthread_t thread);  `

### 线程互斥

1. **临界资源**:凡是被线程共享访问的资源都是临界资源(多线程、多进程打印数据到显示器[临界资源]

2. **临界区**:我的代码中访问临界资源的代码(在我的代码中，不是所有的代码都是进行访问临界资源的。而访问临界资源的代码区域我们称之为临界区)

3. 对临界区进行保护的功能，本质:就是对临界资源的保护。方式:互斥或者同步

4. **互斥**:在任意时刻，只允许一个执行流访问某段代码(访问某部分资源)，就可以称之为互斥!

   比如：printf("hello world") —>  lock(); printf(); unlock();  —>  一个事情要么不执行，要么就执行完毕，具有原子性

5. **同步**：让访问临界资源的过程在安全的前提下（一般都是互斥和原子的），让访问资源具有一定的顺序性！

如果说某个临界资源的访问或修改不是原子的，当多个线程去访问它的时候就很可能出现异常，比如抢票这个过程：

```c++
#include <iostream>
#include <pthread.h>
#include <unistd.h>
#include <time.h>

int tickets = 1000;

// 抢票逻辑，1000张票，5个线程同时抢
void* TreadRoutine(void* args)
{
    int id = *(int*)args;
    delete (int*)args;

    while (true)
    {
        if (tickets > 0)
        {
            usleep(1000); //1s == 1000ms 1ms = 1000us
            std::cout << "我是[" << pthread_self() << "] 我要抢的票是: " << tickets << std::endl;
            tickets--; //这里看起来就是一行C、C++代码
            printf("");
        }
        else
        {
            // 没有票
            break;
        }
    }
}

int main()
{
    pthread_t tid[5];
    for (int i = 0; i < 5; i++)
    {
        int* id = new int(i);
        pthread_create(tid+i, nullptr, TreadRoutine, id);
    }

    for (int i = 0; i < 5; i++)
    {
        pthread_join(tid[i], nullptr);
    }

    return 0;
}
```

**运行结果为**

<img src=".\Image\image-20230418201904596.png" alt="image-20230418201904596" style="zoom:50%;" />

通过运行结果可以发现tickets居然变为了负数，这是因为tickets--这行代码虽然看起来是一行，但实际上底层在执行时要分为几个步骤：将tickets从内存加载到cpu，然后--，最后在内存中修改，出现负数应该就是当一个线程的执行tickets--时，其它几个线程也执行，当tickets马上变为0时好几个进程执行tickets--，然后导致变味为了负数。

很显然上面的情况是不安全的，原因就是tickets--不是原子的

### 加互斥锁

解决上述问题的方法就是对临界区（访问临界资源的代码）加锁

我们对上面的抢票代码进行升级，加上锁

```c++
#include <iostream>
#include <pthread.h>
#include <unistd.h>
#include <time.h>
#include <cstdlib>
#include <mutex>

class Ticket
{
private:
    int tickets; // 临界资源


    pthread_mutex_t mtx; // C语言中的锁
    std::mutex mymtx; // C++中提供的锁

public:
    Ticket()
    :tickets(1000)
    {
        //pthread_mutex_init(&mtx, nullptr);
    }

    
    bool GetTicket()
    {
        static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER; // 定义了这个就不用再初始化和释放锁
        // res是局部变量，所以不是临界资源
        bool res = true;

        pthread_mutex_lock(&mtx); // 使用静态锁就得用这个
        //mymtx.lock();

        if (tickets > 0)
        {
            usleep(1000); //1s == 1000ms 1ms = 1000us
            std::cout << "我是[" << pthread_self() << "] 我要抢的票是: " << tickets << std::endl;
            tickets--; //这里看起来就是一行C、C++代码
            printf("");
            
        }
        else
        {
            // 没有票
            printf("票已经抢完了！\n");
            res = false;
        }
        pthread_mutex_unlock(&mtx);
        //mymtx.unlock();

        return res;

    }

    ~Ticket()
    {
        //pthread_mutex_destroy(&mtx);
    }
};

// 抢票逻辑，1000张票，5个线程同时抢
void* ThreadRoutine(void* args)
{
    Ticket *t = (Ticket*)args;

    //购票的时候，不能出现负数的情况
    // srand((long)time(nullptr));
    while(true)
    {
        if(!t->GetTicket())
        {
            break;
        }
    }
}

int main()
{
    Ticket *t = new Ticket();

    pthread_t tid[5]; // 在内存上开辟了五个线程空间
    for(int i = 0; i < 5; i++)
    {
        int *id = new int(i);
        pthread_create(tid+i, nullptr, ThreadRoutine, (void*)t); // 这里传的是ticket类的对象的指针
    }

    for(int i = 0 ; i < 5; i++){
        pthread_join(tid[i], nullptr);
    }

    return 0;
}
```

上述代码的思想是，在线程访问临界资源tickets的时候，需要先访问mtx锁（因此锁需要定义在前面），那么**锁是不是安全的呢？所本身是不是临界资源？如何保证锁的安全？**

如果一行代码的汇编代码只有一行，那么这行代码就是原子的！

### 互斥锁的原理

<img src=".\Image\image-20230419104629447.png" alt="image-20230419104629447" style="zoom:50%;" />

以下是整个锁的申请过程

1. 首先我们定义了一个锁mutex，mutex实际上就是一个值为1的变量，它是保存在内存中的；
2. 此时有多个线程过来申请锁，线程A过来的最早，于是开始申请锁；
3. 申请的时候就执行上图中的汇编代码，第一行代码就是在寄存器中初始化一个为0的值，第二行代码是交换mutex的值1和寄存器中的值0，第二行代码是一次性执行的，具有原子性；
4. 线程A来的最早执行了前两行代码，线程A的寄存器交换到了1这个值，也即申请到了锁，然后A就可以拿这个值去设置自己的上下文，因为是1所以就可以访问临界区资源（这是由线程内设置好的条件每个线程都是同样的，不然会乱套）；
5. 在A访问临界区的过程中，线程B过来竞争锁，然而此时内存中mutex的值为0，线程B的使用寄存器中交换到的值也为0，只能挂起等待；
6. 直到进程A解锁，mutex被设置为1，进程B才被唤醒，然后竞争锁

**注意：**

- 在线程A上锁的过程中，哪怕执行A的时间片轮转了，其它进程也得等着不能访问临界资源！
- 目前的理解：线程A过来交换值，此时寄存器归A私有，然后值不为零，就return 0; A就可以更新自己的上下文了

### 函数的可重入与线程安全

- **线程安全：**多个线程并发同一段代码时，不会出现不同的结果。常见对全局变量或者静态变量进行操作，并且没有锁保护的情况下，会出现该问题。
- **重入：**同一个函数被不同的执行流调用，当前一个流程还没有执行完，就有其他的执行流再次进入，我们称之为重入。一个函数在重入的情况下，运行结果不会出现任何不同或者任何问题，则该函数被称为可重入函数，否则，是不可重入函数  

**联系**

如果函数不可重入，那么多线程访问函数的时候肯定不安全；如果函数可重入，那么肯定线程安全。

### 死锁

你抱着锁申请锁，然后你被挂起，gg了

### 线程同步

#### 条件变量

- 当一个线程互斥地访问某个变量时，它可能发现在其它线程改变状态之前，它什么也做不了。
- 例如一个线程访问队列时，发现队列为空，它只能等待，直到其它线程将一个节点添加到队列中。那么什么时候队列才不为空了呢？如果让线程时不时的去检查队列是否为空比较麻烦。
- 这种情况就需要用到条件变量。  

**接口、逻辑的代码演示**

```c++
#include <iostream>
#include <string>
#include <pthread.h>
#include <mutex>
#include <unistd.h>

pthread_mutex_t mtx;
pthread_cond_t cond;



void* ctrl(void* args)
{
        std::string name = (char*)args;
    while(true){
        //pthread_cond_signal: 唤醒在条件变量下等待的一个线程，哪一个？？
        //在cond 等待队列里等待的第一个线程
        std::cout << "master say : begin work" << std::endl;
        // pthread_cond_signal(&cond); 
        //唤醒所有线程
        pthread_cond_broadcast(&cond);
        sleep(2);
    }
}

void* work(void* args)
{
    int number = *(int*)args;
    delete (int*)args;

    while (true)
    {
        pthread_cond_wait(&cond, &mtx); // 让线程处于等待状态，当受到cond唤醒的时候再执行
        std::cout << "worker: " << number << " is working ..." << std::endl;
    }
}

int main()
{
#define NUM 5

    pthread_t master;
    pthread_t worker[5];

    pthread_create(&master, nullptr, ctrl, (void*)"master");
    for (int i = 0; i < NUM; i++)
    {
        int* number = new int(i);
        pthread_create(worker+i, nullptr, work, (void*)number);
    }

    for (int i =0; i < NUM; i++)
    {
        pthread_join(worker[i], nullptr);
    }
    pthread_join(master, nullptr);

    pthread_mutex_destroy(&mtx);
    pthread_cond_destroy(&cond);

    return 0;
}
```

**逻辑：**

1. 创建了一个master线程和5个worker线程，接下来的目的是使用master控制worker的执行
2. 先让master进程跑起来，执行ctrl函数；再让5个worker线程跑起来，执行work函数
3. 条件变量是master控制worker的方式，不满足条件先让worker都先wait，当满足条件之后master发出信号，worker们竞争锁，然后执行
4. 然后使用pthread_join函数，因为第二个参数为nullptr说明不关心线程运行状态，因此线程结束后自动释放
5. 最后销毁锁

**接口：**

1. pthread_cond_wait(&cond, &mtx)

   此函数必须配合一把锁来使用，因为这个函数的使用背景是：我们有一块临界资源在线程访问时必须是互斥的，因此访问时是需要竞争到锁。所以我们要让一个线程进入等待状态，那其实就是释放锁，然后挂起自己。等待结束之后再竞争锁

2. pthread_cond_signal(&cond); 

3. pthread_cond_broadcast(&cond);

4. pthread_cond_destroy(&cond);

### 生产者消费者模型

1. 解耦

2. 321原则

   3：3种关系：生vs生、消vs消、消vs生

   2：2种角色：生产者、消费者

   1：1个交易场所：一段缓冲区

**参考代码**:Linux:Lesson/ 510 和 517

### POSIX信号量  

信号量的概念再回顾

1. 信号量本质就是一个计数器，描述临界资源中资源数目的大小（最多能有多少资源分配给线程）

2. 买票的本质是：预定资源。

   如果说临界资源可以被划分成为一个一个小资源，如果处理得当，我们可以实现多个线程访问临界资源的不同区域，从而实现并发（多人同时买票）

> POSIX信号量和SystemV信号量作用相同，都是用于同步操作，**达到无冲突的访问共享资源目的**。但POSIX可以用于线程间同步。 

#### 初始化信号量

```
#include <semaphore.h>
int sem_init(sem_t *sem, int pshared, unsigned int value);
参数：
	pshared:0表示线程间共享，非零表示进程间共享
	value：信号量初始值  
```

#### 销毁信号量

```
int sem_destroy(sem_t *sem);
```

#### 等待信号量

```
功能：等待信号量，会将信号量的值减1
作用：sem_wait是一个函数，也是一个原子操作，它的作用是从信号量的值减去一个“1”，
	 但它永远会先等待该信号量为一个非零值才开始做减法。也就是说，如果你对一个值为2的信号量调用sem_wait()，
	 线程将会继续执行，将信号量的值将减到1。
int sem_wait(sem_t *sem); //P()
```

#### 发布信号量

```
功能：发布信号量，表示资源使用完毕，可以归还资源了。将信号量值加1。
int sem_post(sem_t *sem);//V()  
```

代码参考Linux： Lesson/517

### 线程池

代码参考Linux： Lesson/518

### 单例模式

某些类, 只应该具有一个对象(实例), 就称之为**单例**（Singleton）.（就像线程池一样，多个线程都是在一个对象运行）

在很多服务器开发场景中, 经常需要让服务器加载很多的数据 (上百G) 到内存中. 此时往往要用一个单例的类来管理这些数据。

**对象被设置成单例的场景**

1. 语义上只需要一个对象
2. 该对象内部存在大量的空间，保存了大量的数据，如果允许该对象存在多份，或者允许发生各种拷贝，内存中存在冗余数据

**实现单例模式的方式有两种**

1. **懒汉方式**：吃完饭不洗碗，等下次吃饭的时候再洗碗
2. **饿汉方式**：为了更快吃到饭，这次吃完饭立马洗碗，这样下一次吃饭就可以立马用碗吃饭

单例线程池参考代码：Linux： Lesson/518/sington_thread_pool

### 其他类型的锁

- **悲观锁**：在每次取数据时，总是担心数据会被其他线程修改，所以会在取数据前先加锁（读锁，写锁，行锁等），当其他线程想要访问数据时，被阻塞挂起。
- **乐观锁**：每次取数据时候，总是乐观的认为数据不会被其他线程修改，因此不上锁。但是在更新数据前，会判断其他数据在更新前有没有对数据进行修改。主要采用两种方式：版本号机制和CAS操作。
- **CAS操作**：当需要更新数据时，判断当前内存值和之前取得的值是否相等。如果相等则用新值更新。若不等则失败，失败则重试，一般是一个自旋的过程，即不断重试。
- **自旋锁**，**公平锁**，**非公平锁**？  

自旋锁：不断通过循环检测锁的状态。（适合挂起很短时间的进程）

## Lesson 9 网络基础

**网络的诞生**：最早的计算机主要是为了计算数据，随着计算机数量的增多，一台计算机计算完的数据需要其他计算机计算，因此为了提高效率，所以通过网络来传输数据。

**局域网LAN**：计算机数量更多了, 通过交换机和路由器连接在一起

**广域网WAN**：将远隔千里的计算机都连在一起

### 网络的本质

<img src=".\Image\image-20230509093351413.png" alt="image-20230509093351413" style="zoom:50%;" />

### 认识协议

协议本质就是一种约定，由编码的程序员来决定，这个约定可以帮助我们用某种方式将我们的意思远距离传输。

### 协议分层

在广域网中，肯定存在来自不同国家的不同类型的数据，肯定也有来自不同设备的数据，要实现广域网中所有的设备的交流，就需要协议分层。

### OSI七层模型

- **OSI**（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型，是一个逻辑上的定义和规范;
- 把网络从逻辑上分为了7层. 每一层都有相关、相对应的物理设备，比如路由器，交换机;
- OSI 七层模型是一种框架性的设计方法，其最主要的功能使就是帮助不同类型的主机实现数据传输;
- 它的最大优点是将服务、接口和协议这三个概念明确地区分开来，概念清楚，理论也比较完整. 通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯;
- 但是, 它既复杂又不实用; 所以按照TCP/IP四层模型来学习

### TCP/IP五层(或四层)模型 

> TCP/IP是一组协议的代名词，它还包括许多协议，组成了TCP/IP协议簇.
>
> TCP/IP通讯协议采用了5层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求  

- **物理层:** 负责光/电信号的传递方式. 比如现在以太网通用的网线(双绞线)、早期以太网采用的的同轴电缆(现在主要用于有线电视)、光纤, 现在的wifi无线网使用电磁波等都属于物理层的概念。物理层的能力决定了最大传输速率、传输距离、抗干扰性等. 集线器(Hub)工作在物理层.
- **数据链路层**: 负责设备之间的数据帧的传送和识别. 例如网卡设备的驱动、帧同步(就是说从网线上检测到什么信号算作新帧的开始)、冲突检测(如果检测到冲突就自动重发)、数据差错校验等工作. 有以太网、令牌环网, 无线LAN等标准. 交换机(Switch)工作在数据链路层.
- **网络层**: 负责地址管理和路由选择. 例如在IP协议中, 通过IP地址来标识一台主机, 并通过路由表的方式规划出两台主机之间的数据传输的线路(路由). 路由器(Router)工作在网路层.
- **传输层**: 负责两台主机之间的数据传输. 如传输控制协议 (TCP), 能够确保数据可靠的从源主机发送到目标主机.
- **应用层**: 负责应用程序间沟通，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等. 我们的网络编程主要就是针对应用层  

**一般而言**

- 对于一台主机, 它的操作系统内核实现了从传输层到物理层的内容;
- 对于一台路由器, 它实现了从网络层到物理层;
- 对于一台交换机, 它实现了从数据链路层到物理层;
- 对于集线器, 它只实现了物理层。

### 报头

报头就类似于快递的快递单，需要根据报头来指导当前层进行某种协议决策。

**在计算机操作系统中理解报头**

- 报头是一种结构化的数据
- Linux OS中报头是用C语言写的，具体的报头就是一个结构体

### 局域网工作原理

在一个局域网内，假设有很多台主机接入网络，网络资源是共享的（类似与临界资源）

- 在同一时刻，只能有一台主机向局域网发送数据
- 每台主机都能接收到网络数据，因此主机需要有数据防碰撞算法

### IP地址和MAC地址

IP地址：能够唯一确定一台电脑的标识（一直不变的）

MAX地址：在一定范围内唯一确定一台电脑（不断变化的）

## Lesson 10 网络编程套接字

### 源IP地址和目的IP地址

**IP地址**（公网IP）唯一标识互联网中的一台主机

**源IP，目的IP：**对于一个报头文件来讲，表示它 从哪来，到哪去。最大意义：指导一个报文该如何进行路径选择

### 端口号

数据从主机A到达主机B不是目的，根本目的是到主机B上的一个进程，该进程提供数据处理服务

网络通信实际上也是进程间的通信，IP仅仅是解决了主机之间的通信问题，完了之后还要解决进程间的通信，那么如何确保从主机A发送到主机B的数据能够传递给指定的进程呢？这个时候就需要有**端口号**

**端口号（PORT）**：唯一的标识一台机器上的唯一的一个进程。是一个两字节16位的整数

IP + PORT = 标识互联网中的唯一一个进程 = socket

进程有PID，为什么还要有PORT？

PORT是为了配合IP使用的，其作用类似于人的身份证，网络通信的时候通过socket来寻找进程，而操作系统在管理进程的时候，一是为了是方便管理进程，而是为了不受外部变化的影响（解耦），所以自己使用自己定义的PID来管理进程。

==互联网的世界，其实就是进程间通信的世界==

### TCP协议

此处我们先对TCP(Transmission Control Protocol **传输控制协议**)有一个直观的认识

- 传输层协议
- 有连接
- 可靠传输
- 面向字节流  

### IDP协议

此处我们也是对UDP(User Datagram Protocol **用户数据报协议**)有一个直观的认识

- 传输层协议
- 无连接
- 不可靠传输
- 面向数据报  

### 网络字节序

我们已经知道,内存中的多字节数据相对于内存地址有大端和小端之分, 磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分, 网络数据流同样有大端小端之分. 那么如何定义网络数据流的地址呢?

- 发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出;
- 接收主机把从网络上接到的字节依次保存在接收缓冲区中,也是按内存地址从低到高的顺序保存;
- 因此,网络数据流的地址应这样规定:先发出的数据是低地址,后发出的数据是高地址.
- **TCP/IP协议规定,网络数据流应采用大端字节序,即低地址高字节**.
- 不管这台主机是大端机还是小端机, 都会按照这个TCP/IP规定的网络字节序来发送/接收数据;
- 如果当前发送主机是小端, 就需要先将数据转成大端; 否则就忽略, 直接发送即可;  

### socket编程接口

#### socket常见API

```c++
// 创建 socket 文件描述符 (TCP/UDP, 客户端 + 服务器)
int socket(int domain, int type, int protocol);

// 绑定端口号 (TCP/UDP, 服务器)
int bind(int socket, const struct sockaddr *address, socklen_t address_len);

// 开始监听socket (TCP, 服务器)
int listen(int socket, int backlog);

// 接收请求 (TCP, 服务器)
int accept(int socket, struct sockaddr* address, socklen_t* address_len);

// 建立连接 (TCP, 客户端)
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

#### sockaddr结构

socket API是一层抽象的网络编程接口,适用于各种底层网络协议,如IPv4、 IPv6,以及后面要讲的UNIX Domain Socket. 然而, 各种网络协议的地址格式并不相同

- IPv4和IPv6的地址格式定义在netinet/in.h中,IPv4地址用**sockaddr_in**结构体表示,包括16位地址类型, 16位端口号和32位IP地址.
- IPv4、 IPv6地址类型分别定义为常数AF_INET、 AF_INET6. 这样,只要取得某种sockaddr结构体的首地址,不需要知道具体是哪种类型的sockaddr结构体,就可以根据地址类型字段确定结构体中的内容.
- socket API可以都用struct sockaddr *类型表示, 在使用的时候需要强制转化成sockaddr_in; 这样的好处是程序的通用性, 可以接收IPv4, IPv6, 以及UNIX Domain Socket各种类型的sockaddr结构体指针做为参数

```c++
/* Structure describing an Internet socket address.  */
struct sockaddr_in
{
    __SOCKADDR_COMMON (sin_);
    in_port_t sin_port;			/* Port number.  */
    struct in_addr sin_addr;		/* Internet address.  */
 
    /* Pad to size of `struct sockaddr'.  */
    unsigned char sin_zero[sizeof (struct sockaddr)
			   - __SOCKADDR_COMMON_SIZE
			   - sizeof (in_port_t)
			   - sizeof (struct in_addr)];
};
```

#### recvfrom

```c++
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                        struct sockaddr *src_addr, socklen_t *addrlen);
```

### socket小程序：UDP

参考Linux: Lesson/708/udp

这个小程序需要认真学习和理解

### socket小程序：TCP

参考Linux: Lesson/708/tcp

**查看网络服务指令**：`netstat -nltp`

### socket编程接口及使用

————————————————   参考来源
版权声明：本文为CSDN博主「接受平凡 努力出众」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/m0_58367586/article/details/127566056

————————————————   参考来源

#### socket()

```c++
SYNOPSIS
       #include <sys/socket.h>
       int socket(int domain, int type, int protocol);

DESCRIPTION
       The socket() function shall create an unbound socket in a communications domain, and return a file descriptor that can be used in later function
       calls that operate on sockets.
    
       domain Specifies the communications domain in which a socket is to be created.
			AF_INET 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址
			AF_INET6 与上面类似，不过是来用IPv6的地址
			AF_UNIX 本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用
       type   Specifies the type of socket to be created.
			SOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。
			SOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。
			SOCK_SEQPACKET该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。
			SOCK_RAW socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议）
			SOCK_RDM 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序
       protocol
			传0 表示使用默认协议。
RETURN VALUE
	成功：返回指向新创建的socket的文件描述符，失败：返回-1，设置errno
```

#### bind()

```c++
SYNOPSIS
       #include <sys/socket.h>
       int bind(int socket, const struct sockaddr *address,
              socklen_t address_len);

DESCRIPTION
       socket       socket文件描述符
			  Specifies the file descriptor of the socket to be bound.
       address	    构造出IP地址加端口号
    		  Points  to  a  sockaddr  structure  containing  the address to be bound to the socket. The length and format of the address depend on the
              address family of the socket.
       address_len  sizeof(addr)长度
              Specifies the length of the sockaddr structure pointed to by the address argument.

       The socket specified by socket may require the process to have appropriate privileges to use the bind() function.

RETURN VALUE
       Upon successful completion, bind() shall return 0; otherwise, -1 shall be returned and errno set to indicate the error.
```

服务器程序所监听的网络地址和端口号通常是固定不变的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接，因此服务器需要调用bind绑定一个固定的网络地址和端口号。
bind()的作用是将参数socket和sockaddr绑定在一起，使socket这个用于网络通讯的文件描述符监听address所描述的地址和端口号。前面讲过，struct sockaddr *是一个通用指针类型，address参数实际上可以接受多种协议的sockaddr结构体，而它们的长度各不相同，所以需要第三个参数address_len指定结构体的长度。如：

```c++
struct sockaddr_in servaddr;
bzero(&servaddr, sizeof(servaddr));
servaddr.sin_family = AF_INET;
servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
servaddr.sin_port = htons(6666);
```

- 首先将整个结构体清零，
- 然后设置地址类型为AF_INET，
- 网络地址为INADDR_ANY，这个宏表示本地的任意IP地址，因为服务器可能有多个网卡，每个网卡也可能绑定多个IP地址，这样设置可以在所有的IP地址上监听，直到与某个客户端建立了连接时才确定下来到底用哪个IP地址，端口号为6666。

#### listen()

对于服务器端程序，使用 bind() 绑定套接字后，还需要使用 listen() 函数让套接字进入被动监听状态，再调用 accept() 函数，就可以随时响应客户端的请求了。

```c++
#include <sys/types.h> /* See NOTES */
#include <sys/socket.h>
int listen(int sockfd, int backlog);
sockfd:
	socket文件描述符
backlog:
	排队建立3次握手队列和刚刚建立3次握手队列的链接数和
查看系统默认backlog
cat /proc/sys/net/ipv4/tcp_max_syn_backlog
```

典型的服务器程序可以同时服务于多个客户端，当有客户端发起连接时，服务器调用的accept()返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未accept的客户端就处于连接等待状态，listen()声明sockfd处于监听状态，并且**最多允许有backlog个客户端处于连接待状态**，如果接收到更多的连接请求就忽略。listen()成功返回0，失败返回-1。

所谓被动监听，是指当没有客户端请求时，套接字 处于“睡眠”状态，只有当接收到客户端请求时，套接字才会被“唤醒”来响应请求。

#### accept()

listen() 只是让套接字处于监听状态，并没有接收请求。接收请求需要使用 accept() 函数，当套接字处于监听状态时，可以通过 accept() 函数来接收客户端请求。

```c++
#include <sys/types.h> 		
#include <sys/socket.h>
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
sockdf:
	socket文件描述符
addr:
	传出参数，返回链接客户端地址信息，含IP地址和端口号
addrlen:
	传入传出参数（值-结果）,传入sizeof(addr)大小，函数返回时返回真正接收到地址结构体的大小
返回值：
	成功返回一个新的socket文件描述符，用于和客户端通信，失败返回-1，设置errno
```

**accept() 返回一个新的套接字来和客户端通信，addr 保存了客户端的IP地址和端口号，而 sock 是服务器端的套接字，注意区分。后面和客户端通信时，要使用这个新生成的套接字，而不是原来服务器端的套接字**

### 客户端的接口

#### connect()

```c++
#include <sys/types.h> 					/* See NOTES */
#include <sys/socket.h>
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
sockdf:
	socket文件描述符
addr:
	传入参数，指定服务器端地址信息，含IP地址和端口号
addrlen:
	传入参数,传入sizeof(addr)大小
返回值：
	成功返回0，失败返回-1，设置errno
 
```

### 其它的小接口

#### htons()

**htons() 是网络字节序与主机字节序之间转换的函数**，需要转化的原因是网络字节序是大端字节序，就是说一个数字的权值高的位在低地址位置，权值低的位在高地址位置（这个位置的不同指的是不同字节值之间的相对位置）；然而很多主机的字节序确未必是大端，因此需要转化为按照大端排列的网络字节序。

### Linux网络如何传输数据

Linux 不区分套接字文件和普通文件，使用 write() 可以向套接字中写入数据，使用 read() 可以从套接字中读取数据。

前面我们说过，两台计算机之间的通信相当于两个套接字之间的通信，在服务器端用 write() 向套接字写入数据，客户端就能收到，然后再使用 read() 从套接字中读取出来，就完成了一次通信。

#### write()

```c++
ssize_t write(int fd, const void *buf, size_t nbytes);
```

#### read()

```c++
ssize_t read(int fd, void *buf, size_t nbytes);
```

fd 为要读取的文件的描述符，buf 为要接收数据的缓冲区地址，nbytes 为要读取的数据的字节数。

**read() 函数会从 fd 文件中读取 nbytes 个字节并保存到缓冲区 buf，成功则返回读取到的字节数（但遇到文件结尾则返回0），失败则返回 -1。**

#### recv()

```c++
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
```

| 参数   | 描述                                                        |
| ------ | ----------------------------------------------------------- |
| sockfd | socket 文件描述符                                           |
| buf    | 接收数据缓冲区                                              |
| len    | 接收数据缓冲区的大小                                        |
| flags  | 标志，一般置0，若需要设置多个标志，则通过 “或” 逻辑进行连接 |

flags 可以设置为如下几种：

| flags 标志       |
| ---------------- |
| MSG_CMSG_CLOEXEC |
| MSG_CMSG_CLOEXEC |
| MSG_DONTWAIT     |
| MSG_ERRQUEUE     |
| MSG_OOB          |
| MSG_PEEK         |
| MSG_TRUNC        |
| MSG_WAITALL      |

返回值

- 成功：接收到的字节数
- 失败：-1，并设置 errno
- 其他：当出现如下情况时，返回0
  - 当流套接字（socket 函数中参数 type = SOCK_STREAM）对端关闭连接时，返回值将为0；
  - UNIX 和 Internet 域数据报套接字允许长度为0的数据报。当接收到这样的数据报时，返回值为0；
  - 当流套接字对端发送长度为0的数据段，也可以返回值0。

### 冷知识

先看代码

```c++
ssize_t s = write(sock, json_string.c_str(), json_string.size());

char buffer[1024];
s = read(sock, buffer, sizeof(buffer) - 1);
if (s > 0)
{
    response_t resp;
    buffer[s] = 0;
    std::string str = buffer;
    DeserializeResponse(str, resp);

    cout << "code[0:success]: " << resp.code << endl;
    cout << "result: " << resp.result << std::endl;
}
```

在第1行中写入字符串时是按照完整的字符串大小写入的，而在第4行读取时却少读了一个字节的字符串？

1. 首先因为我们的读写是针对网络通信的，网络传输数据时只考虑报文大小，或者是字节流中字节的个数，没有C/C++中字符串的概念，因此我们传输的只是一定字节的数据
2. 接收到字节流的数据之后，我们认为是字符串，那么就用char类型的数据来接收
3. 然而存在一个问题是我们传输字符串时，末尾的'\0'已经被处理成了数字0（ascII值为48），意义已经变了
4. 因此我们直接不读取最后一个字节的0，而是自己手动在末尾添加'\0'
5. 0 == '\0'

我理解的到底对不对？？？好像不对，因为不这样手动加'\0'也没问题。。。

我又测试了一下，确实不用手动加'\0'也可以。。。

==上面的理解是不对的，减一是因为sizeof计算的是大小，而下标是从0开始的。==

## Lesson 11 网络基础2

### 简单过程

1. 创建socket的过程，socket()，本质是打开文件 -- 仅仅有系统相关的内容
2. bind()，struct sockaddr_in -> ip，port，本质是ip+port和文件信号进行关联
3. listen()，本质是设置该socket文件的状态，允许别人来连接我
4. accept()，获取新链接到应用层，是以fd为代表的
5. read/write，本质就是进行网络通信，但是对于用户来讲相当于我们在进行正常的文件读写
6. close(fd)，关闭文件。a.系统层面，释放曾经申请的文件资源，连接资源等。b. 网络层面，通知对方，我的连接已经关闭了
7. connect()，本质是发起链接，在系统层面就是构建一个请求报文发送过去，在网络层面，发起tcp三次握手
8. close()，client &&  server， 本质在网络层面，其实就是在进行四次握手！

<img src=".\Image\image-20230523110842760.png" alt="image-20230523110842760" style="zoom:67%;" />

### 应用层

### 序列化和反序列化

- 定义结构体来表示我们需要交互的信息;
- 发送数据时将这个结构体按照一个规则转换成字符串, 接收到数据的时候再按照相同的规则把字符串转化回结构体;
- 这个过程叫做 "序列化" 和 "反序列化"  

一端发送时构造的数据, 在另一端能够正确的进行解析, 就是ok的. 这种约定, 就是**应用层协议**  

### HTTP协议

协议本质也就是一个约定，参见代码net_cal，位置 Linux : Lesson/710/cal_net，这是一个应用层的网络服务。

http（超文本传输协议）也是一个应用层协议

#### 认识URL

URL就是平常说的“网址”，IP + Port可以唯一确定一个进程，但是无法唯一确认一个资源，公网IP地址是唯一确认一台主机的，而我们所谓的网络资源，都一定是存在于网络中的一台Linux机器上！Linux或者传统的操作系统，保存资源的方式，都是以文件的方式保存的。单Linux系统，标识一个唯一资源的方式，通过路径！

所以==IP + Linux路径就可以唯一的确定一个网络资源==

![image-20230522203534997](.\Image\image-20230522203534997.png)

#### URL转码和解码

像 / ? : 等这样的字符, 已经被url当做特殊意义理解了. 因此这些字符不能随意出现。比如， 某个参数中需要带有这些特殊字符, 就必须先对特殊字符进行转义.  

转义的规则如下:
将需要转码的字符转为16进制，然后从右到左，取4位(不足4位直接处理)，每2位做一位，前面加上%，编码成%XY格式  

### HTTP协议格式

简单认识：无论是请求还是响应，http基本上都是按照行（\n）为基本单位的，一般都是由3或者4部分组成。

如何理解普通用户的上网行为？1. 从目标服务器上拿到想要的资源 2. 向目标服务器上传你的数据

#### HTTP请求方法

- 首行: [方法] + [url] + [版本]
- Header: 请求的属性, 冒号分割的键值对；每组属性之间使用\n分隔；遇到空行表示Header部分结束  
- Body: 空行后面的内容都是Body. Body允许为空字符串. 如果Body存在, 则在Header中会有一个
- Content-Length属性来标识Body的长度;  

根据 HTTP 标准，HTTP 请求可以使用多种**请求方法**。

HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。**短链接**：一个请求，一个响应，close socket

HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。

| 序号 | 方法    | 描述                                                      |
| :--: | :------ | :------------------------------------------------------ |
|  1   | GET     | 请求指定的页面信息，并返回实体主体。                         |
|  2   | HEAD    | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 |
|  3   | POST    | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 |
|  4   | PUT     | 从客户端向服务器传送的数据取代指定的文档的内容。             |
|  5   | DELETE  | 请求服务器删除指定的页面。                                   |
|  6   | CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。    |
|  7   | OPTIONS | 允许客户端查看服务器的性能。                                 |
|  8   | TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                   |
|  9   | PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。           |

#### GET和POST的区别

get方法的请求，将表单中的内容和url拼接在一起

![image-20230523175020975](.\Image\image-20230523175020975.png)

post请求的方式

![image-20230523174929637](.\Image\image-20230523174929637.png)

总结： 

1. **get ：获取**，是最常用的方法，默认一般获取所有的网页，都是get方法，如果要使用get方法提交参数，使用过url拼接从而提交给server端
2. **post：推送**，是提交参数比较常用的方法，但是如果提交参数，一般是通过正文部分提交的，但是不要忘记Content-Length:xxx表示参数的长度

区别：

1. 参数提价的位置不同，post方法比较私密（私密 != 安全），不会回显到浏览器的url输入框，而get方法会将重要信息显示到输入框中，增加了被盗取的概率
2. get通过url传参，而url是有大小限制的，和具体的浏览器有关；post方法通过正文传参，一般是没有大小限制的。

如何选择

1. 如果提交的参数不敏感，数量比较少，可以采用get
2. 否则采用post

#### HTTP状态码

应用层诗人要参与的，然而参与的人水平不齐，乱用和误用状态码的情况很严重，如果浏览器检查状态码严格的话，很多网页代码跑不起来，因此浏览器都在放低检查标准，形成了恶性内卷，直到现在，一些状态码对浏览器基本没什么指导意义，也就是说浏览器根本不care有些状态码出现的原因。比如404。<img src=".\Image\image-20230523203432983.png" alt="image-20230523203432983" style="zoom:67%;" />

#### 3XX状态码

3XX状态是有特殊含义的，重定向：

1. 永久重定向 301

   网站搬迁，域名更换，浏览器将书签也会对应更改

2. 临时重定向 302 307

   访问一个网站时需要登陆，登陆时跳转到另一个页面，登陆完再返回

#### HTTP常见Header

- Content-Type: 数据类型(text/html等)
- Content-Length: Body的长度
- Host: 客户端告知服务器, 所请求的资源是在哪个主机的哪个端口上;
- User-Agent: 声明用户的操作系统和浏览器版本信息;
- referer: 当前页面是从哪个页面跳转过来的;
- location: 搭配3xx状态码使用, 告诉客户端接下来要去哪里访问;
- Cookie: 用于在客户端存储少量信息. 通常用于实现会话(session)的功能;  

#### cookie与session

http本身是一种无状态的协议，不会记录一次请求的上下文，也就是说每次请求都是不相关的。**但是日常生活中，我们登录了某个网站，然后在进行网站跳转的时候，网站照样认识我们，不需要每次都登陆**，这个不是http本身需要解决的问题，但是http可以提供一些技术支持，来保证网站具有“**会话保持**”的功能。

主要是通过cookie来进行会话管理

**cookie**

1. 浏览器：cookie实际上是一个文件，该文件里面保存的是用户的私密信息，有些cookie信息存在本地文件中，有的存在内存中
2. http协议：一旦该网站对应有cookie，在发起任何请求的时候，都会自动在requst（报头属性）中携带cookie信息

<img src=".\Image\image-20230605203915643.png" alt="image-20230605203915643" style="zoom:67%;" />

可以看出最后一行加入了cookie的信息。

单纯使用cookie具有很大的危险，一旦恶意网站得到了用户的cookie信息，很可能能够获取用户的账户和密码。

**session**

核心思路是：**将用户的私密信息保存在服务器端**。

1. 对象不同

   **cookie**：是针对每个网站的信息，每个网站只能对应一个，其他网站无法访问，这个文件保存在客户端，每次您拨打相应网站，浏览器都会查找该网站的 cookies，如果有，则会将该文件发送出去。cookies文件的内容大致上包括了诸如用户名、密码、设置等信息。

   **session**：是针对每个用户的，只有客户端才能访问，程序为该客户添加一个 session。session中主要保存用户的登录信息、操作信息等等。此 session将在用户访问结束后自动消失(如果也是超时)。

2. 存储数据大小不同

   **cookie**：一个 cookie存储的数据不超过3K。

   **session**：session存储在服务器上可以任意存储数据。当 session存储数据太多时，服务器可选择进行清理。

3. 生命周期不同

   **cookie**：cookie的生命周期当浏览器关闭的时候就消亡了，cookie的生命周期是累计的，从创建时就开始计时，30min后cookie生命周期结束。

   **session**：session的生命周期是间隔的，从创建时开始计时如在30min内没有访问session，那么session生命周期就被销毁。

4. 存储位置不同

   **cookie**：cookie数据保存在客户端。

   **session**：session数据保存在服务器端。

5. 数据类型不同

   两者都是key-value结构，但针对value的类型是有差异的。

   **cookie**：value只能是字符串类型。

   **session**：value是object类型。

6. 安全性不同

   cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，如果主要考虑到安全应当使用session。

**cookie+session的本质**：提高用户访问网站或者平台的体验

**session工作原理图**

<img src=".\Image\image-20230727170053470.png" alt="image-20230727170053470" style="zoom:50%;" />

### HTTPS

https = http + TLS/SSL

TLS/SSL： 数据的加密层解密层

#### 加密方式

1. 对称加密：密钥只有一个

   例如：密钥为X， data ^ X = result     result ^ X = data

2. 非对称加密：有一对密钥，公钥和私钥

   - 可以用公钥加密，但是只能用私钥解密

   - 可以用私钥加密，但是只能用公钥解密

   一般而言，公钥是全世界公开的，私钥是必须自己进行私有保存的。

####  如何判断内容有没有被修改？

一篇文章，用Hash散列算法对其进行映射生成一个字符序列，特点是：，若是文章修改一个标点符号，生成的字符序列差异也会很大，对文章进行加密然后传输，解密后用相同的Hash散列进行映射，判断生成的序列是否相同

#### 非对称加密存在的问题

按道理来说，server端和client端互相发送自己的密钥之后，再采用对称加密加密数据，这既能保证传输安全，也能避免非对称加密和解密运算量大的问题，但是存在一个问题是玩意server和client之间有中间人窃取了公钥，将自己的公钥发送给client，通过这种方式完全可以实现数据盗取。那么如何避免这个问题呢？如何判定自己接收到的公钥是安全的呢？

通过CA证书机构背书，CA机构给正规的公司发布证书

#### CA证书的原理

首先需要明白，证书授权(Certificate Authority, CA)的存在意义：就是对server进行认证，然后使用散列函数对server的公钥+机构信息生成信息摘要，然后再使用CA私钥对信息摘要加密形成数字签名，这样可以保证公钥不被修改，具体如下：

1. client向目标server发送请求

2. server将自己的**公钥+机构信息+数字签名**发给发给client （数字签名包括：原文+公钥+机构信息）

3. client收到server发送的内容后，使用与CA相同的散列函数对**公钥+机构信息**生成信息摘要，然后使用CA公钥解密数字签名，再比对信息摘要是否被修改（注意这里是关键：**数字签名就是绑定了服务端的公钥和机构信息，这个数字签名只能由CA使用私钥来生成，而公钥早已经内置的在支持CA证书的浏览器中**）

4. 此时就算有中间人获取到了内容，也不能修改，如果修改了server发送的公钥，那么使用散列函数生成的信息摘要就会改变，**此时使用CA公钥解密数字签名得到信息摘要**，通过对比就会发现信息摘要不一致。

   如果中间人是合法机构，将自己的公钥+机构信息和数字签名发送给client，client能够发现公钥+机构信息与自己发起请求的机构不一致，也可保证安全。

   数字签名是由CA私钥产生的，中间人无法生成数字签名。

这个过程其实就是server通过CA机构背书，完成了自己公钥准确无误发送给client，同样的client也可以通过CA机构背书完成对server端准确无误发送公钥，发送完了之后就可以用对方的公钥加密自己的数据，这样只有对方可以用私钥解密，实现非对称加密。也可以通过CA机构发送一个私钥完成对称式加密，节省开销。

实现上面这一切的前提是client需要直到CA的公钥和散列函数，当然，这些都是浏览器内置的。

### 传输层

#### 再谈端口号

端口号(Port)标识了一个主机上进行通信的不同的应用程序;  

在TCP/IP协议中, 用 "源IP", "源端口号", "目的IP", "目的端口号", "协议号" 这样一个五元组来标识一个通信(可以通过netstat -n查看);  

#### 两个问题

1. 一个进程是否可以bind多个端口号?
2. 一个端口号是否可以被多个进程bind?  

#### UDP

##### UDP协议端格式

<img src=".\Image\image-20230617095649147.png" alt="image-20230617095649147" style="zoom:50%;" />

- 16位UDP长度, 表示整个数据报(UDP首部+UDP数据)的最大长度;
- 如果校验和出错, 就会直接丢弃;  

##### UDP的特点

传输过程类似于寄信

- **无连接:** 知道对端的IP和端口号就直接进行传输, 不需要建立连接;
- **不可靠:** 没有确认机制, 没有重传机制; 如果因为网络故障该段无法发到对方, UDP协议层也不会给应用层返回任何错误信息;
- **面向数据报:** 不能够灵活的控制读写数据的次数和数量;  

##### 面向数据报

应用层交给UDP多长的报文, UDP原样发送, 既不会拆分, 也不会合并;

用UDP传输100个字节的数据:

- 如果发送端调用一次sendto, 发送100个字节, 那么接收端也必须调用对应的一次recvfrom, 接收100个字节; 而不能循环调用10次recvfrom, 每次接收10个字节  

#### TCP

##### TCP协议段格式

<img src=".\Image\image-20230619113924212.png" alt="image-20230619113924212" style="zoom:33%;" />

数据偏移也就是4位首部长度，单位是4字节，也就是说20字节的固定首部的4位首部长度是5

##### 确认应答机制

TCP全称为 "传输 控制 协议(Transmission Control Protocol"). 人如其名, 要对数据的传输进行一个详细的控制。

TCP可靠性的核心：确认应答机制。

<img src=".\Image\image-20230618192946160.png" alt="image-20230618192946160" style="zoom: 33%;" />

##### TCP报文中的标志位含义

- URG: 紧急指针是否有效，表明报文中是否有紧急数据（紧急数据的位置由16位紧急指针确定）
- ACK: 确认号是否有效
- PSH: 提示接收端应用程序立刻从TCP缓冲区把数据读走
- RST: 对方要求重新建立连接（重置异常连接）; 我们把携带RST标识的称为复位报文段
- SYN: 请求建立连接; 我们把携带SYN标识的称为同步报文段
- FIN: 通知对方, 本端要关闭了, 我们称携带FIN标识的为结束报文段

##### TCP传输原理

TCP协议，是自带发送和接受缓冲区的！ TCP实际上会malloc 2 段内存空间：发送 + 接收

我们的==**发送接口**==write/send函数：实际上将数据拷贝到TCP的发送缓冲区，然后TCP进行传递

==**接收接口**==read/recv函数：实际上是从TCP的接收缓冲区读取数据

在我们应用层，我们只需要调用接口，将数据交给TCP，剩下的都是由TCP来传输，具体传输过程中的问题都是TCP来解决，数据怎么发什么时候发。==因为由缓冲区的存在，所以可以做到应用层和发送层进行解耦==

##### 三次握手

tcp是面向链接的，要通信的时候，需要先connect，那么如何建立链接？

1. 首先三次握手，本质是三次数据交换，交换三次报文

   三次握手通俗的含义是

   - client对server说（SYN）：做我女朋友吧
   - server回应client说（SYN+ACK）：好呀，什么时候啊？
   - client说（ACK）：就现在

2. 三次握手成功后，在双方的OS内为维护该链接创建对应的数据结构，通过先描述再组织的方式管理

三次握手并不能保证一定可以连接成功，而是能够以较大的概率连接成功

##### 四次挥手

这是断开连接的过程，具体过程为：

- client给server发送带有FIN标志的报文
- server给client发送带有ACK标志的报文进行确认
- 然后server再给client发送带有FIN标志的报文
- 最后client给server发送带有ACK标志的报文进行确认

##### 连接管理机制

<img src="https://cdn.lanluo.cn/wp-content/uploads/2022/09/640-1.png" alt="img" style="zoom: 67%;" />

##### 为什么需要三次握手而不是四次或更多？

我们的目的是要验证双方的主机是否健康，能否达到通信条件，采用三次握手

==可以验证全双工，就是说验证每个主机是否可以完成发数据和收数据，而三次握手是验证双方可以发送和接收数据的最小次数==

三次握手的另一个好处是可以防止一个主机恶意的多次建立连接，若是只用一次或者两次握手就建立连接，那么不能很好的防止别的主机不断地发送SYN报文进行连接（SYN洪水），有了三次握手才建立连接的话，其他的主机就不能恶意一次性发送好多建立连接的请求，而是要根据你的回复速度（第二次握手的速度）来建立连接，并且采用三次握手的策略，两主机建立连接的成本是一样的。

同样的，四次挥手是协商断开连接的最小次数，所谓协商断开连接就是一个主机说我要断开，另一个主机说好。

##### TIME_WAIT状态

client向server发送断开连接的请求，四次挥手之后，client会进入TIME_WAIT状态

有两个主要原因

1. MSL是TCP报文的最大生存时间, 因此TIME_WAIT持续存在2MSL的话就能**保证在两个传输方向上的尚未被接收或迟到的报文段都已经消失**(否则服务器立刻重启, 可能会收到来自上一个进程的迟到的数据, 但是这种数据很可能是错误的);
2. 同时也是在理论上保证最后一个报文可靠到达(假设最后一个ACK丢失, 那么服务器会再重发一个FIN. 这时虽然客户端的进程不在了, 但是TCP连接还在, 仍然可以重发LAST_ACK);  

**解决TIME_WAIT状态引起的bind失败的方法**

- 在server的TCP连接没有完全断开之前不允许重新监听, 某些情况下可能是不合理的    
- 服务器需要处理非常大量的客户端的连接(每个连接的生存时间可能很短, 但是每秒都有很大数量的客户端来请求).
  这个时候如果由服务器端主动关闭连接(比如某些客户端不活跃, 就需要被服务器端主动清理掉), 就会产生大量TIME_WAIT连接.
- 由于我们的请求量很大, 就可能导致TIME_WAIT的连接数很多, 每个连接都会占用一个通信五元组(源ip,源端口, 目的ip, 目的端口, 协议). 其中服务器的ip和端口和协议是固定的. 如果新来的客户端连接的ip和端口号和TIME_WAIT占用的链接重复了, 就会出现问题. 

使用setsockopt()设置socket描述符的 选项SO_REUSEADDR为1, 表示允许创建端口号相同但IP地址不同的多个socket描述符  

参考Lesson/717/Http.cc

##### 滑动窗口

发送报文的时候，每发送一个都需要有确认应答，如果每次都等到上一个报文的确认应答收到之后才发送报文，那么会很浪费时间，为了效率我们使一定数量的报文在发送时不需要上一个报文的确认应答，无需确认应答的报文的数量就是**滑动窗口大小**，其实就是对方主机提供的报文缓冲区的大小。滑动窗口的大小是由接收主机的接收能力决定的，这是动态变化的。

这个过程其实就是我们先给对方发一些数据，然后再挨个确认，而不是发一个确认一个再发下一个。（就像做饭一样，可以先把水烧上，然后切菜等等）

**滑动窗口**就是有些报文得到确认之后，向右（或者说后）移动，继续发送报文。滑动窗口是在发送主机的发送缓冲区中移动，而滑动窗口的大小是接收主机告诉发送主机的

滑动窗口是不可能向左移动的，因为左边的报文都是得到确认的报文。

在传输过程中会遇到一些问题

1. 滑动窗口内中部分ACK（接收主机）丢失

   这个不用担心，只要收到了后面的ACK的序号，就能确保前面的数据接收主机已经接收到了

2. 滑动窗口中部分数据丢失

   如过前面的部分数据丢失，那么接收主机就不可能会发送后面的ACK序号，当接收主机多次发送丢失的确认序号后，发送主机再发送一遍就行，这样下一次就是直接受到后面的ACK序号（这个过程叫**快重传**）

#####  流量控制

接收端处理数据的速度是有限的. 如果发送端发的太快, 导致接收端的缓冲区被打满, 这个时候如果发送端继续发送,就会造成丢包, 继而引起丢包重传等等一系列连锁反应.

因此TCP支持根据接收端的处理能力, 来决定发送端的发送速度. 这个机制就叫做**流量控制(Flow Control)**  

- 接收端将自己可以接收的缓冲区大小放入 TCP 首部中的 "窗口大小" 字段, 通过ACK端通知发送端;
- 窗口大小字段越大, 说明网络的吞吐量越高;
- 接收端一旦发现自己的缓冲区快满了, 就会将窗口大小设置成一个更小的值通知给发送端;
- 发送端接受到这个窗口之后, 就会减慢自己的发送速度;
- 如果接收端缓冲区满了, 就会将窗口置为0; 这时发送方不再发送数据, 但是需要定期发送一个窗口探测数据段, 使接收端把窗口大小告诉发送端.  

接收端如何把窗口大小告诉发送端呢? 回忆TCP首部中, 有一个16位窗口字段, 就是存放了窗口大小信息;

那么问题来了, 16位数字最大表示65535, 那么TCP窗口最大就是65535字节么?

实际上, TCP首部40字节选项中还包含了一个窗口扩大因子M, 实际窗口大小是 窗口字段的值左移 M 位;  

##### 拥塞控制

虽然TCP有了滑动窗口这个大杀器, 能够高效可靠的发送大量的数据. 但是如果在刚开始阶段就发送大量的数据, 仍然可能引发问题.
因为网络上有很多的计算机, 可能当前的网络状态就已经比较拥堵. 在不清楚当前网络状态下, 贸然发送大量的数据,是很有可能引起雪上加霜的.

滑动窗口其实不只需要考虑接收方主机的接收能力，还得考虑网络状况，也就是说还得考虑拥塞窗口，因此

==滑动窗口大小=min(拥塞窗口大小，对方窗口大小)==

至于这个拥塞窗口的大小如何确定，TCP引入 **慢启动** 机制, 先发少量的数据, 探探路, 摸清当前的网络拥堵状态, 再决定按照多大的速度传输数据;。

##### 延迟应答

- 如果接收数据的主机立刻返回ACK应答, 这时候返回的窗口可能比较小 
- 假设接收端缓冲区为1M. 一次收到了500K的数据; 如果立刻应答, 返回的窗口就是500K;
- 但实际上可能处理端处理的速度很快, 10ms之内就把500K数据从缓冲区消费掉了;
- 在这种情况下, 接收端处理还远没有达到自己的极限, 即使窗口再放大一些, 也能处理过来;
- 如果接收端稍微等一会再应答, 比如等待200ms再应答, 那么这个时候返回的窗口大小就是1M;  

一定要记得, 窗口越大, 网络吞吐量就越大, 传输效率就越高. 我们的目标是在保证网络不拥塞的情况下尽量提高传输效率;

那么所有的包都可以延迟应答么? 肯定也不是;

- 数量限制: 每隔N个包就应答一次;
- 时间限制: 超过最大延迟时间就应答一次;

具体的数量和超时时间, 依操作系统不同也有差异; 一般N取2, 超时时间取200ms

##### 捎带应答

在延迟应答的基础上, 我们发现, 很多情况下, 客户端服务器在应用层也是 "一发一收" 的. 意味着客户端给服务器说了 "How are you", 服务器也会给客户端回一个 "Fine, thank you";

那么这个时候ACK就可以搭顺风车, 和服务器回应的 "Fine, thank you" 一起回给客户端 

##### 面向字节流

创建一个TCP的socket, 同时在内核中创建一个 发送缓冲区 和一个 接收缓冲区;

- 调用write时, 数据会先写入发送缓冲区中;
- 如果发送的字节数太长, 会被拆分成多个TCP的数据包发出;
- 如果发送的字节数太短, 就会先在缓冲区里等待, 等到缓冲区长度差不多了, 或者其他合适的时机发送出去;接收数据的时候, 
- 数据也是从网卡驱动程序到达内核的接收缓冲区;
- 然后应用程序可以调用read从接收缓冲区拿数据;
- 另一方面, TCP的一个连接, 既有发送缓冲区, 也有接收缓冲区, 那么对于这一个连接, 既可以读数据, 也可以写数据. 这个概念叫做 全双工

由于缓冲区的存在, TCP程序的读和写不需要一一匹配, 例如:

- 写100个字节数据时, 可以调用一次write写100个字节, 也可以调用100次write, 每次写一个字节;
- 读100个字节数据时, 也完全不需要考虑写的时候是怎么写的, 既可以一次read 100个字节, 也可以一次read一个字节, 重复100次;  

就类似于水利工程一样，要进行南水北调，那么就需要将水先存在一个蓄水池中，然后再进行水的运输，水是的存储方式和水的运输方式没有关系。

##### 粘包问题

##### TCP异常问题

- 进程终止: 进程终止会释放文件描述符, 仍然可以发送FIN. 和正常关闭没有什么区别.
- 机器重启: 和进程终止的情况相同.
- 机器掉电/网线断开: 接收端认为连接还在, 一旦接收端有写入操作, 接收端发现连接已经不在了, 就会进行reset. 即使没有写入操作, TCP自己也内置了一个保活定时器, 会定期询问对方是否还在. 如果对方不在, 也会把连接释放.
- 另外, 应用层的某些协议, 也有一些这样的检测机制. 例如HTTP长连接中, 也会定期检测对方的状态. 例如QQ, 在QQ断线之后, 也会定期尝试重新连接.  

##### TCP小结

为什么TCP这么复杂? 因为要保证可靠性, 同时又尽可能的提高性能.

###### 可靠性:

校验和

- 序列号(按序到达)
- 确认应答
- 超时重发
- 连接管理
- 流量控制
- 拥塞控制

###### 提高性能:

- 滑动窗口
- 快速重传
- 延迟应答
- 捎带应答

###### 其他:

- 定时器(超时重传定时器, 保活定时器, TIME_WAIT定时器等  

#### TCP/UDP对比

TCP是可靠连接, 那么是不是TCP一定就优于UDP呢? TCP和UDP之间的优点和缺点, 不能简单, 绝对的进行比较

- TCP用于可靠传输的情况, 应用于文件传输, 重要状态更新等场景;
- UDP用于对高速传输和实时性要求较高的通信领域, 例如, 早期的QQ, 视频传输等. 另外UDP可以用于广播;

归根结底, TCP和UDP都是程序员的工具, 什么时机用, 具体怎么用, 还是要根据具体的需求场景去判定  

#### listen函数第二个参数

客户端状态正常, 但是服务器端出现了 SYN_RECV 状态, 而不是 ESTABLISHED 状态
这是因为, Linux内核协议栈为一个tcp连接管理使用两个队列:

1. 半链接队列（用来保存处于SYN_SENT和SYN_RECV状态的请求）
2. 全连接队列（accpetd队列）（用来保存处于established状态，但是应用层没有调用accept取走的请求）

而全连接队列的长度会受到 listen 第二个参数的影响.
全连接队列满了的时候, 就无法继续让当前连接的状态进入 established 状态了.
这个队列的长度通过上述实验可知, 是 listen 的第二个参数 + 1.  

## Lesson 12 网络基础3

### 网络层

### IP协议

IP = 网络号 + 主机号

TCP解决的是数据发送的策略问题，就是如何发，要不要重发等等

IP协议解决的是执行问题，就是具体来执行数据传输

### 协议头格式

<img src=".\Image\image-20230628112527627.png" alt="image-20230628112527627" style="zoom:50%;" />

### 网段划分

IP地址分为两个部分, **网络号**和**主机号**

- **网络号**: 保证相互连接的两个网段具有不同的标识;
- **主机号**: 同一网段内, 主机之间具有相同的网络号, 但是必须有不同的主机号;  

**子网：**就是把网络号相同的主机放在一起，但是需要做到区分每个主机

通过合理设置主机号和网络号, 就可以保证在相互连接的网络中, 每台主机的IP地址都不相同，也就是说可以在互联网中唯一确定一台主机

这就需要对同一个子网中的主机号进行合理划分，手动管理子网内的IP, 是一个相当麻烦的事情

- 有一种技术叫做DHCP, 能够自动的给子网内新增主机节点分配IP地址, 避免了手动管理IP的不便.一般的路由器都带有DHCP功能. 因此路由器也可以看做一个DHCP服务器.  

到了这里我们可以知道ip划分的逻辑：先根据网络号划分大的范围，大这些大的范围进行区分，然后在这些大的范围中使用主机号进一步划分小的范围。最初有一种划分网络号的主机号的方式，将ip地址分为五类：

<img src=".\Image\image-20230628161151241.png" alt="image-20230628161151241" style="zoom:50%;" />

- A类 0.0.0.0到127.255.255.255
- B类 128.0.0.0到191.255.255.255
- C类 192.0.0.0到223.255.255.255
- D类 224.0.0.0到239.255.255.255
- E类 240.0.0.0到247.255.255.255  

随着Internet的飞速发展，这种划分方案的局限性很快显现出来，大多数组织都申请B类网络地址,，导致B类地址很快就分配完了，而A类却浪费了大量地址  

- 例如, 申请了一个B类地址, 理论上一个子网内能允许6万5千多个主机. A类地址的子网内的主机数更多.然而实际网络架设中, 不会存在一个子网内有这么多的情况. 因此大量的IP地址都被浪费掉了.  

为了解决上述问题，子网掩码出现了。

### 子网掩码

在最初的划分方案的基础之上，新的划分方案,出现了，称为CIDR(Classless Interdomain Routing)：

- 引入一个额外的子网掩码(subnet mask)来区分网络号和主机号;
- 子网掩码也是一个32位的正整数. 通常用一串 "0" 来结尾;
- 将IP地址和子网掩码进行 "按位与" 操作, 得到的结果就是网络号;
- 网络号和主机号的划分与这个IP地址是A类、B类还是C类无关  

#### 举个例子

| 名称         | 序列                        | 16进制      |
| ------------ | --------------------------- | ----------- |
| IP地址       | 140.252.20.68               | 8C FC 14 44 |
| 子网掩码     | 255.255.255.0               | FF FF FF 00 |
| 网络号       | 140.252.20.0                | 8C FC 14 00 |
| 子网地址范围 | 140.252.20.0~140.252.20.255 |             |

计算过程

```c++
140.252.20.68 == 140       152       20        0100 0010
255.255.255.0 == 1111 1111 1111 1111 1111 1111 0000 0000
    // 按位&
        &     == 140       152       20        0000 0000
    // 此时前半段的序列固定了，使用子网掩码相当于将20这个子网号给拆开了
    // 所以子网中的主机号可以是0000 0000 ~ 1111 1111 
    // 除去 0000 0000 和 1111 1111，共可以分配253台主机
```

上面这个例子好像并不能说明子网掩码的作用，再看一个例子结合来看：

| 名称         | 序列                        | 16进制      |
| ------------ | --------------------------- | ----------- |
| IP地址       | 140.252.20.68               | 8C FC 14 44 |
| 子网掩码     | 255.255.255.240             | FF FF FF 00 |
| 网络号       | 140.252.20.64               | 8C FC 14 00 |
| 子网地址范围 | 140.252.20.64~140.252.20.79 |             |

注意看子网地址范围，可以看出子网掩码的真正作用是：==20这个子网中本来总共可以分配253台主机，而配合上子网掩码可以将范围限制在64~79，也就是只能分配15台，可以将其余的再生成一个子网掩码然后再分配给其它人，这样可以减少20这个子网IP的浪费。==

#### 特殊的IP地址

- 将IP地址中的主机地址全部设为0, 就成为了网络号, 代表这个局域网;
- 将IP地址中的主机地址全部设为1, 就成为了广播地址, 用于给同一个链路中相互连接的所有主机发送数据包;
- 127.*的IP地址用于本机环回(loop back)测试,通常是127.0.0.1

#### 唯一确定一台主机的方式

拿上面的IP举例，IP:140.252.20.68

其中140.252是网络号，20是子网号，68就代表着68号主机

### IP地址数量限制

然而子网掩码只是解决了IP地址的浪费，我们可以算一下就算将所有的IP地址（IPV4）使用，也就是2^32个IP地址，大概43亿，很显然还是不够用的。

还有三种方案来解决不够用的问题：

- 动态分配IP地址: 只给接入网络的设备分配IP地址. 因此同一个MAC地址的设备, 每次接入互联网中, 得到的IP地址不一定是相同的;
- NAT技术(后面会重点介绍);
- IPv6: IPv6并不是IPv4的简单升级版. 这是互不相干的两个协议, 彼此并不兼容; IPv6用16字节128位来表示一个IP地址;但是目前IPv6还没有普及;  

### 私有IP和公有IP

如果一个组织内部组建局域网，IP地址只用于局域网内的通信,而不直接连到Internet上，理论上使用任意的IP地址都可以，但是RFC 1918规定了用于组建局域网的私有IP地址  

### 流量 && 运营商

我们平常使用抖音、腾讯视频等需要联网的软件进行上网，有一个大的前提，就是要么使用流量，要么使用Wi-Fi，这些都是需要给运营商进行付费，因为，中国的互联网是运营商搭建的，我们的所有的网络请求都是需要经过运营商的搭建的基础设备，不可能绕过运营商，中国互联网的一切基础是运营商！

### 私有IP地址和公有IP地址

如果一个组织内部组建局域网，IP地址只用于局域网内的通信，而不直接连到Internet上，理论上使用任意的IP地址都可以，但是RFC 1918规定了用于组建局域网的私有IP地址  

- 10.*,前8位是网络号,共16,777,216个地址
- 172.16.到*172.31.*,前12位是网络号,共1,048,576个地址
- 192.168.*,前16位是网络号,共65,536个地址
  包含在这个范围中的, 都成为私有IP, 其余的则称为全局IP(或公网IP);  

#### 路由器简介

- 一个路由器可以配置两个IP地址, 一个是WAN口IP, 一个是LAN口IP(子网IP).
- 路由器LAN口连接的主机, 都从属于当前这个路由器的子网中.
- 不同的路由器, 子网IP其实都是一样的(通常都是192.168.1.1). 子网内的主机IP地址不能重复. 但是子网之间的IP地址就可以重复了.
- 每一个家用路由器, 其实又作为运营商路由器的子网中的一个节点. 这样的运营商路由器可能会有很多级,最外层的运营商路由器, WAN口IP就是一个公网IP了.
- 子网内的主机需要和外网进行通信时, 路由器将IP首部中的IP地址进行替换(替换成WAN口IP), 这样逐级替换, 最终数据包中的IP地址成为一个公网IP. 这种技术称为NAT(Network Address Translation，网络地址转换).
- 如果希望我们自己实现的服务器程序, 能够在公网上被访问到, 就需要把程序部署在一台具有外网IP的服务器上. 这样的服务器可以在阿里云/腾讯云上进行购买  

### 路由

路由的过程，就是这样一跳一跳(Hop by Hop) "问路" 的过程。

所谓 "一跳" 就是数据链路层中的一个区间. 具体在以太网中指从源MAC地址到目的MAC地址之间的帧传输区间 

IP数据包的传输过程也和问路一样.

- 当IP数据包, 到达路由器时, 路由器会先查看目的IP;
- 路由器决定这个数据包是能直接发送给目标主机, 还是需要发送给下一个路由器;
- 依次反复, 一直到达目标IP地址;   

那么如何判定当前这个数据包该发送到哪里呢? 这个就依靠每个节点内部维护一个路由表  

- 路由表可以使用route命令查看  
- 如果目的IP命中了路由表, 就直接转发即可;
- 路由表中的最后一行,主要由下一跳地址和发送接口两部分组成,当目的地址与路由表中其它行都不匹配时,就按缺省路由条目规定的接口发送到下一跳地址。  

### 数据链路层

我们的网络通信过程，其实就是将数据从一个主机跨越多个局域网传输到另一台主机上，期间会经历多个节点，在传输过程中：

1. HTTP等协议在应用层告诉程序员如何将数据打包发送
2. TCP等协议在传输层保证数据安全可靠的传输
3. IP协议在网络层告诉路由器是否需要跳转，路由器根据IP判断如何跳转以及跳转到哪
4. 这一切的基础都是由数据链路层来完成的

那么数据链路层是如何进行的呢？

### 以太网

- "以太网" 不是一种具体的网络, 而是一种技术标准; 既包含了数据链路层的内容, 也包含了一些物理层的内容. 例如: 规定了网络拓扑结构, 访问控制方式, 传输速率等;
- 例如以太网中的网线必须使用双绞线; 传输速率有10M, 100M, 1000M等;
- 以太网是当前应用最广泛的局域网技术; 和以太网并列的还有令牌环网, 无线LAN等;

### 以太网帧格式

在应用层，我们发送了一个==请求==，然后传输层加上报头后称为==数据段==，网络层再加上报头称为==数据包==，到数据链路层加上报文就变成了==数据帧==。

<img src=".\Image\image-20230630164438695.png" alt="image-20230630164438695" style="zoom: 33%;" />



### MAC地址

- MAC地址用来识别数据链路层中相连的节点;
- 长度为48位, 及6个字节. 一般用16进制数字加上冒号的形式来表示(例如: 08:00:27:03:fb:19)
- 在网卡出厂时就确定了, 不能修改. mac地址通常是全球唯一的(虚拟机中的mac地址不是真实的mac地址, 可能会冲突; 也有些网卡支持用户配置mac地址)  

### MTU

MTU相当于发快递时对包裹尺寸的限制. 这个限制是不同的数据链路对应的物理层, 产生的限制.  

- 以太网帧中的数据长度规定最小46字节,最大1500字节,ARP数据包的长度不够46字节,要在后面补填充位;
- 最大值1500称为以太网的最大传输单元(MTU),不同的网络类型有不同的MTU;  
- 如果一个数据包从以太网路由到拨号链路上,数据包长度大于拨号链路的MTU了,则需要对数据包进行分片(fragmentation);
- 不同的数据链路层标准的MTU是不同的  

### ARP协议

ARP不是一个单纯的数据链路层的协议, 而是一个介于数据链路层和网络层之间的协议。

ARP协议建立了主机 IP地址 和 MAC地址 的映射关系.

> - 在网络通讯时,源主机的应用程序知道目的主机的IP地址和端口号,却不知道目的主机的硬件地址;
> - 数据包首先是被网卡接收到再去处理上层协议的,如果接收到的数据包的硬件地址与本机不符,则直接丢弃;
> - 因此在通讯前必须获得目的主机的硬件地址;  

### ARP的工作流程

1. 源主机发出ARP请求,询问“IP地址是192.168.0.1的主机的硬件地址是多少”, 并将这个请求广播到本地网段(以太网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播);
2. 目的主机接收到广播的ARP请求,发现其中的IP地址与本机相符,则发送一个ARP应答数据包给源主机,将自己的硬件地址填写在应答包中;
3. 每台主机都维护一个ARP缓存表,可以用arp -a命令查看。缓存表中的表项有过期时间(一般为20分钟),如果20分钟内没有再次使用某个表项,则该表项失效,下次还要发ARP请求来获得目的主机的硬件地址  

### 其他重要协议或技术  

### DNS(Domain Name System)  

TCP/IP中使用IP地址和端口号来确定网络上的一台主机的一个程序. 但是IP地址不方便记忆.于是人们发明了一种叫主机名的东西, 是一个字符串, 并且使用hosts文件来描述主机名和IP地址的关系.  

### 域名简介 

主域名是用来识别主机名称和主机所属的组织机构的一种分层结构的名称  

域名使用 . 连接

- com: 一级域名. 表示这是一个企业域名. 同级的还有 "net"(网络提供商), "org"(非盈利组织) 等.
- baidu: 二级域名, 公司名.
- www: 只是一种习惯用法. 之前人们在使用域名时, 往往命名成类似于ftp.xxx.xxx/www.xxx.xxx这样的格式, 来表示主机支持的协议.  

### 浏览器中输入url之后会发生什么？

#### 宏观层面

1. 首先在地址栏输入域名，然后浏览器进行域名解析，拿到IP地址，根据IP+端口号，浏览器发起HTTP请求
2. 服务端收到HTTP请求，读取并分析HTTP请求，根据请求中的参数和需要的资源等构建HTTP响应，然后发送给浏览器
3. 浏览器对响应进行分析，将响应中的网页内容提取出来，对网页内容进行解释和渲染，展示给用户

#### 细节方面

1. 当我们客户端发起HTTP请求的时候，底层实际上调用的是TCP的套接字connect进行连接的，将HTTP请求使用TCP协议的报文格式拷贝进发送缓冲区，然后以字节流的方式进行传输，这期间会发生很多事情，TCP通过自己的各种机制（三次握手，确认应答，快重传，超时重传等）来保证传输
2. 传输过程中包括传输层、网络层、数据链路层

### ICMP协议

简单说ICMP协议可以提供网络出错的原因

### NAT技术

之前我们讨论了, IPv4协议中, IP地址数量不充足的问题，NAT技术当前解决IP地址不够用的主要手段, 是路由器的一个重要功能;

- NAT能够将私有IP对外通信时转为全局IP. 也就是就是一种将私有IP和全局IP相互转化的技术方法:
- 很多学校, 家庭, 公司内部采用每个终端设置私有IP, 而在路由器或必要的服务器上设置全局IP;
- 全局IP要求唯一, 但是私有IP不需要; 在不同的局域网中出现相同的私有IP是完全不影响的;  

==NAT技术解决IP不够用的思路是：如果我们要给全球每一台设备都给一个唯一的IP地址显然是不够用的，而且也是没必要的，比如说，中国的很多的网络通信在中国大的局域网之内完成，也就是说只需要在中国的局域网之内可以区别这些主机就好，因此可以给这些主机私有的IP地址（相对来说）在中国的局域网通信时采用私有IP就可以，当有主机要访问美国的主机时再通过NAT技术将私有IP转化为公有IP即可==

#### 具体的过程

当主机向外网发送请求时，路由器会将私有IP和公有IP进行映射，从而实现IP的唯一，当然中国的主机访问美国的主机时，需要经过非常多层的映射。

#### NAPT

那么问题来了, 如果局域网内, 有多个主机都访问同一个外网服务器, 那么对于服务器返回的数据中, 目的IP都是相同的. 那么NAT路由器如何判定将这个数据包转发给哪个局域网的主机?

==这时候NAPT来解决这个问题了. 使用IP+port来建立这个关联关系==

这种关联关系也是由NAT路由器自动维护的. 例如在TCP的情况下, 建立连接时, 就会生成这个表项; 在断开连接后, 就会删除这个表项

#### NAT技术的缺陷

由于NAT依赖这个转换表, 所以有诸多限制:

- 无法从NAT外部向内部服务器建立连接;
- 装换表的生成和销毁都需要额外开销;
- 通信过程中一旦NAT设备异常, 即使存在热备, 所有的TCP连接也都会断开;

### 内网穿透(NAT穿越)

曾经我在使用jupyter的时候使用过内网穿透，当时对这个概念完全不懂，只是使用了一下。有空了再研究。

### NAT和代理服务器

路由器往往都具备NAT设备的功能, 通过NAT设备进行中转, 完成子网设备和其他子网设备的通信过程.代理服务器看起来和NAT设备有一点像. 客户端像代理服务器发送请求, 代理服务器将请求转发给真正要请求的服务器; 服务器返回结果后, 代理服务器又把结果回传给客户端.

那么NAT和代理服务器的区别有哪些呢?

- 从应用上讲, NAT设备是网络基础设备之一, 解决的是IP不足的问题. 代理服务器则是更贴近具体应用, 比如通过代理服务器进行翻墙, 另外像迅游这样的加速器, 也是使用代理服务器.
- 从底层实现上讲, NAT是工作在网络层, 直接对IP地址进行替换. 代理服务器往往工作在应用层.
- 从使用范围上讲, NAT一般在局域网的出口部署, 代理服务器可以在局域网做, 也可以在广域网做, 也可以跨网.
- 从部署位置上看, NAT一般集成在防火墙, 路由器等硬件设备上, 代理服务器则是一个软件程序, 需要部署在服务器上. 

代理服务器是一种应用比较广的技术.

- 翻墙: 广域网中的代理.
- 负载均衡: 局域网中的代理   

### 访问外网

#### 国家为什么能够保护我们？

- 首先我们知道，中国大陆的一切网络都是运营商搭建的，我们对互联网的任何访问都不可能绕过运营商；
- 其次，IP在分配的时候都是经过精心设计的，并且我们要访问的IP运营商都是能够监控到的；
- 我们想访问国外的某些主机，很显然需要公网IP，而运营商立能知道我们要访问的IP是否健康；
- 因此，当不该我们访问的IP出现在运营商的主机中时，里面就会被切断。

#### 那为什么有些人可以挣脱保护？

由于我国先进的特色制度，所以HongKong地区存在一些主机，这些主机并不受国家的保护，可以随意访问外网，而且这些主机也可以随意被大陆地区的主机访问，有了这个前提就可以绕过一些保护

- 我们要访问某个被限制的国外网站，首先得连接HongKong地区的服务器，然后不直接向该网站发送请求，而是向HK服务器发送加密后的请求；
- 此时运营商看到了你的访问的IP是HK地区的，而且请求内容还是加密的，运营商没法判断你的请求是否有问题，因此不会做限制，此时你就可以正常向HK服务器请求了；
- 然后HK服务器会将你的请求解密，并向对应的国外网站进行请求，得到响应后再加密传输给我们

当然了，上述过程需要配套的APP和加密算法等等，你的所有网络请求都被APP劫持，然后APP用自己的方式发送请求。

#### 国外可以随意访问中国网站吗？

不一定，运营商是可以识别出国外主机的源IP的，因此国外也需要HK服务器来访问国内网站。

## Lesson 13 高级IO

网络通信的本质是：IO，IO的效率是比较低下的

IO = 等 + 拷贝

实际上大部分时间IO类的接口都在等待

### 五种IO模型

- **阻塞IO**: 在内核将数据准备好之前, 系统调用会一直等待. 所有的套接字, 默认都是阻塞方式 
- **非阻塞轮询式IO**: 如果内核还未将数据准备好, 系统调用仍然会直接返回, 并且返回EWOULDBLOCK错误码
- **信号驱动IO**: 内核将数据准备好的时候, 使用SIGIO信号通知应用程序进行IO操作  
- **IO多路转接**: 虽然从流程图上看起来和阻塞IO类似. 实际上最核心在于IO多路转接能够同时等待多个文件描述符的就绪状态.
- **异步IO**: 由内核在数据拷贝完成时, 通知应用程序(而信号驱动是告诉应用程序何时可以开始拷贝数据).  	

### 高级IO的重要概念

#### 同步通信和异步通信

同步和异步关注的是消息通信机制.

- 所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回. 但是一旦调用返回，就得到返回值了; 换句话说，就是由调用者主动等待这个调用的结果;
- 异步则是相反， 调用在发出之后，这个调用就直接返回了，所以没有返回结果; 换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果; 而是在调用发出后， 被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用.  	

**注意：**同步的概念应该是：同时开始，步调一致。在通信中同步就是步调一致的意思，然而在多线程中，同步的意思应该分开来看：同是协同的意思，总体的意思应该是协同步调，按照顺序进行。

#### 阻塞 vs 非阻塞

阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.

- 阻塞调用是指调用结果返回之前，当前线程会被挂起. 调用线程只有在得到结果之后才会返回.
- 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程  				

**举例**

将默认为阻塞式的标准输入改为非阻塞式

```c++
#include <iostream>
#include <unistd.h>
#include <fcntl.h>
#include <cerrno>
#include <string.h>

bool SetNonBlock(int fd)
{
    int fl = fcntl(fd, F_GETFL); // 在底层获取当前fd对应的文件读写标志位
    if (fl < 0)
        return false;

    fcntl(fd, F_SETFL, fl | O_NONBLOCK); // 设置非阻塞
    return true;
}

int main()
{
    // 标准输入 文件描述符 0 标准输入默认情况下是阻塞式的
    SetNonBlock(0); // 设置标准输入为非阻塞
    char buffer[1024];
    while (true)
    {
        sleep(1);
        errno = 0;
        ssize_t s = read(0, buffer, sizeof(buffer) - 1); // 当读取失败的时候，errno会被设置为错误类型
        if (s > 0)
        {
            buffer[s-1] = 0; // 输入的时候最后一位是回车，这就相当于把回车删掉
            std::cout << "echo# " << buffer << " errno[---]: " << errno << " errstring: " << strerror(errno) << std::endl;
        }
        else
        {
            // TODO
            if (errno == EWOULDBLOCK || errno == EAGAIN)
            {
                std::cout << "当前0好fd数据没有就绪，请下一次来试试吧" << std::endl;
            }
            else if (errno == EINTR)
            {
                std::cout << "当前IO可能被信号中断，再试一试吧" << std::endl;
                continue;
            }
            else
            {
                // 
            }
        }
    } 

    return 0;
}
```

### 多路转接

系统提供select函数来实现多路复用输入/输出模型  

- select系统调用是用来让我们的程序监视多个文件描述符的状态变化的;
- 程序会停在select这里等待，直到被监视的文件描述符有一个或多个发生了状态改变;  

### select

#### select接口

```c++
#include <sys/select.h>

int select(int nfds, fd_set *restrict readfds,fd_set *restrict writefds, fd_set *restrict errorfds,
            struct timeval *restrict timeout);
```

**参数解释:**

- 参数nfds是需要监视的最大的文件描述符值+1；（因为这个参数表示的是监听的文件的个数，而文件描述符从0开始）
- rdset,wrset,exset分别对应于需要检测的可读文件描述符的集合，可写文件描述符的集合及异常文件描述符的集合;
- 参数timeout为结构timeval，用来设置select()的等待时间

参数timeout取值:

- NULL：则表示select（）没有timeout， select将一直被阻塞，直到某个文件描述符上发生了事件;
- 0：仅检测描述符集合的状态，然后立即返回，并不等待外部事件的发生。
- 特定的时间值：如果在指定的时间段里没有事件发生， select将超时返回。  

**fd_set结构**

其实这个结构就是一个整数数组, 更严格的说, 是一个 "位图". 使用位图中对应的位来表示要监视的文件描述符  

![image-20230703203011613](.\Image\image-20230703203011613.png)

注意：除了第一个位置的参数，其余参数都具有输入输出性

#### select的优缺点

**优点** -- 任何一个多路转接方案都具备：

1. 效率高
2. 应用场景：有大量的链接，但是只有少量是活跃的，省资源

**缺点**

1. 为了维护第三方数组，select服务器会充满大量的遍历，OS底层帮我们关心fd的时候也要遍历
2. 每一次都要对select输出参数进行重新设定
3. 能够同时管理的fd的个数是有上限的
4. 因为几乎每一个参数都是输入输出型的，select一定会频繁的进行用户到内核与内核到用户的参数数据拷贝
5. 编码比较复杂

### Poll

```c++
#include <poll.h>
	
int poll(struct pollfd *fds, nfds_t nfds, int timeout);

struct pollfd 
{
    int   fd;         /* file descriptor */
    short events;     /* requested events */
    short revents;    /* returned events */
};

```

poll是一种多路转接的方案，和select一样，只做一件事情，那就是 等

**参数说明**

- fds是一个poll函数监听的结构列表. 每一个元素中, 包含了三部分内容: 文件描述符, 监听的事件集合, 返回的事件集合.
- nfds表示fds数组的长度.
- timeout表示poll函数的超时时间, 单位是毫秒(ms)

events和revents的取值:  

<img src=".\Image\image-20230704201559706.png" alt="image-20230704201559706" style="zoom: 50%;" />

**返回结果**

- 返回值小于0, 表示出错;
- 返回值等于0, 表示poll函数等待超时;
- 返回值大于0, 表示poll由于监听的文件描述符就绪而返回.  （也就是说监听的文件有新的变化）

#### poll的优缺点

**优点：**

1. 效率高
2. 有大量的连接，但是只有少量的是活跃的。节省资源
3. 输入输出参数是分离的，不需要进行大量的重置
4. poll参数级别，没有可以管理的fd上限

**缺点：**

1. poll依旧需要不少的遍历，在用户层检测事件就绪，与内核检测fd就绪，都是一样
2. poll需要内核到用户进行拷贝
3. poll的代码也比较复杂，但是比select容易

### epoll

**句柄**（Handle）是一个用来标识对象或者项目的标识符，可以用来描述窗体、文件等，值得注意的是句柄不能是常量，可以理解为一个广义的指针。

> 按照man手册的说法: epoll是为处理大批量句柄而作了改进的poll.它是在2.5.44内核中被引进的(epoll(4) is a new API introduced in Linux kernel 2.5.44)它几乎具备了之前所说的一切优点，被公认为Linux2.6下性能最好的多路I/O就绪通知方法.  

#### epoll相关系统调用

epoll_create()

```c++
int epoll_create(int size);  
```

创建一个epoll的句柄，返回值是一个文件描述符

- 自从linux2.6.8之后， size参数是被忽略的.
- 用完之后, 必须调用close()关闭.  

epoll_ctl()

```c++
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
```

epoll的事件注册函数。

它不同于select()是在监听事件时告诉内核要监听什么类型的事件, 而是在这里先注册要监听的事件类型.

- 第一个参数是epoll_create()的返回值(epoll的句柄).
- 第二个参数表示动作，用三个宏来表示.
- 第三个参数是需要监听的fd.
- 第四个参数是告诉内核需要监听什么事.

第二个参数的取值:

- EPOLL_CTL_ADD ：注册新的fd到epfd中；
- EPOLL_CTL_MOD ：修改已经注册的fd的监听事件；
- EPOLL_CTL_DEL ：从epfd中删除一个fd  

struct epoll_event结构如下:

```c++
 typedef union epoll_data {
   void        *ptr;
   int          fd;
   uint32_t     u32;
   uint64_t     u64;
} epoll_data_t;

struct epoll_event {
   uint32_t     events;      /* Epoll events */
   epoll_data_t data;        /* User data variable */
};
```

events可以是以下几个宏的集合：

- EPOLLIN : 表示对应的文件描述符可以读 (包括对端SOCKET正常关闭);
- EPOLLOUT : 表示对应的文件描述符可以写;
- EPOLLPRI : 表示对应的文件描述符有紧急的数据可读 (这里应该表示有带外数据到来);
- EPOLLERR : 表示对应的文件描述符发生错误;
- EPOLLHUP : 表示对应的文件描述符被挂断;
- EPOLLET : 将EPOLL设为边缘触发(Edge Triggered)模式, 这是相对于水平触发(Level Triggered)来说的.
- EPOLLONESHOT：只监听一次事件, 当监听完这次事件之后, 如果还需要继续监听这个socket的话, 需要再次把这个socket加入到EPOLL队列里  

epoll_wait()

```c++
int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);
```

收集在epoll监控的事件中已经发送的事件.（就是管理用户让内核管理的事件，如果有事件发生就进行反馈）

参数events是分配好的epoll_event结构体数组.

- epoll将会把发生的事件赋值到events数组中 (events不可以是空指针，内核只负责把数据复制到这个events数组中，不会去帮助我们在用户态中分配内存).
- maxevents告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的size.
- 参数timeout是超时时间 (毫秒， 0会立即返回， -1是永久阻塞).
- 如果函数调用成功，返回对应I/O上已准备好的文件描述符数目，如返回0表示已超时, 返回小于0表示函数失败  

> 考虑两个问题1.OS是怎么是知道网卡里面有数据了？2.OS怎么知道键盘由用户输入了？
>
> 当网卡或者键盘收到数据之后，会发送一个脉冲中断信号给CPU上特定的模块，这个模块会将信号转化为寄存器中的一个值，通过这个值，OS会找到一个中断向量表，然后找到对应的方法，执行对应的操作。

#### epoll原理

用户在调用epoll时，内核中会创建一个红黑树，这个红黑树中存的是用户告诉内核，让内核监听的文件描述符和事件；内核会一直维护这个红黑树，然后自动生成一个就绪队列，用户通过接口来访问这个队列。

内核是如何监听这些文件和事件的？（类似OS监听键盘输入）

- 在创建红黑树时，每个节点都对应一个回调方法，这个回调方法被注册到硬件层（网卡驱动中），当节点关心的事件就绪时，回调方法启动，然后创建一个ready_node，加入到就绪队列中
- 有了这些回调方法，内核就不用频繁去遍历红黑树

#### epoll细节

1. 创建红黑树的时候的key值是文件描述符

2. 用户使用epoll时只需要设置关系，获取结果即可，不用再关心任何对fd和event的管理细节

3. epoll高效的原因

   - 不需要OS经常去遍历需要监听的文件，就绪文件会通过回调函数自动加入到就绪队列中，用户通过接口访问就绪队列即可

4. 底层只要有fd就绪了，OS自动会构建节点链入到就绪队列中，然后用户通过接口拿走就绪队列中的节点

   这个过程是一个==生产者消费者模型==！队列就是共享资源-临界资源，epoll已经为这个过程进行了处理，可以保证访问是安全的。

5. 如果就绪队列里面没有就绪事件的时候，就需要进入阻塞等待，这个通过epoll_wait中的timeout参数进行设置。

#### epoll工作方式

你正在吃鸡, 眼看进入了决赛圈, 你妈饭做好了, 喊你吃饭的时候有两种方式:

1. 如果你妈喊你一次, 你没动, 那么你妈会继续喊你第二次, 第三次...(亲妈, 水平触发LT)
2. 如果你妈喊你一次, 你没动, 你妈就不管你了(后妈, 边缘触发ET)  

**LT和ET**

- LT

  如果有就绪的数据，就会一直提醒程序员处理

- ET

  如果有就绪的数据，提醒程序员一次，然后就再不提醒了

<img src=".\Image\image-20230707173021674.png" alt="image-20230707173021674" style="zoom:80%;" />

注意：ET模式中对于文件的读取需要设置成非阻塞式，因为ET只会提醒一次，让服务端读取用户请求，万一服务端一次性没有读取完所有数据，就不会给客户端发送响应，客户端也不会再次向服务端发送请求，会造成服务停止。

### TcpServer梳理和总结

首先简单介绍一下此TcpSerVer服务器的构成

> 此服务器的核心内容是：基于TCP协议的网络通信、基于Epoll的多路转接模型(ET工作模式)、基于低耦合的搭建方式、基于C++编程、基于Linux操作系统

#### 层次结构

TcpServer由上到下可以划分为四层：1.应用层  2.多路转接层 3. 通信层 4.内核层

多路转接层主要是依靠Epoll来实现，epoll的高性能, 是有一定的特定场景的. 如果场景选择的不适宜, epoll的性能可能适得其反.

- 对于多连接, 且多连接中只有一部分连接比较活跃时, 比较适合使用epoll.
  例如, 典型的一个需要处理上万个客户端的服务器, 例如各种互联网APP的入口服务器, 这样的服务器就很适合epoll.
- 如果只是系统内部, 服务器和服务器之间进行通信, 只有少数的几个连接, 这种情况下用epoll就并不合适. 具体要根据需求和场景特点来决定使用哪种IO模型

#### 文件结构

搭建TcpServer服务器总共需要7个文件

1. main.cc

   服务器的启动文件，负责服务的启动（多路转接层）、请求的处理（应用层）

2. TcpServer.hpp

   服务器的核心（大脑），统一管理着所有的操作和事件，核心功能为：

   - Epoll模型的建立和管理
   - TCP通信的管理
   - 服务的分发的处理

3. Sock.hpp

   TCP通信的所有接口的封装文件

4. Epoll.hpp

   Epoll模型管理的所有接口封装文件

5. Protocol.hpp

   服务端和客户端通信协议的制定文件，主要为了解决粘包问题，对于一个完整的请求报文中的内容进行分解，做对应的处理

6. Log.hpp

   日志生成与打印文件，输出服务器的运行信息，方便debug和检查

7. Makefile

   负责编译服务器的所有文件

#### 服务器运转流程

下面描述一下从服务器启动，到一个客户端和服务端建立联系并进行通信，最后断开链接的整个过程。

1. 让服务器跑起来

   创建TcpServer对象

   在创建对象的过程中要完成对服务器的完整构建，调用构造函数来执行，构造函数里面要完成：

   1. _listensock的创建、绑定、监听

   2. _epoll模型的创建

   3. 将_listensock添加到服务器中，等待建立连接

      此过程调用AddConnection方法实现

      1. 设置sock为非阻塞（这是因为ET模式下防止不能一次将文件（缓冲区）中的数据读完）
      2. 构建conn对象，封装sock。具体：绑定回调方法，初始化回值指针，添加sock到epoll中，添加 (sock,回调方法) 到服务器链接映射表中（方便对大量链接进行有效管理和执行对应操作）

   4. 构建一个获取就绪事件的缓冲区_recv，方便对大量事件进行管理

2. 服务端和客户端建立链接

   1. 此时服务器处于就绪状态，通过Dispatch函数循环调用LoopOnce函数，让服务器处于对连接请求的持续监控状态
   2. 当客户端通过IP+port向服务端发出建立链接的请求时，epoll模型中管理的_listensock文件就会处于读就绪队列中，epoll将读就绪事件进行反馈，服务器中的LoopOnce方法处于循环调用执行中
   3. LoopOnce方法执行时，对处于epoll所反馈的就绪文件进行依次处理（遍历事件缓冲区），一次遍历中，拿到就绪事件的sock（初次连接时为_listensock），然后根据事件类型，从服务器连接映射表中拿到（sock，回调方法），然后调用连接方法并执行，此时初次连接的操作已经完成，并且会分配新的sock用于通信
   4. 将新创建的sock加入到服务器链接映射表中，并绑定三个回调方法

3. 客户端向服务端发送请求

   1. 通过新分配的sock进行通信，发送一个消息，epoll会返回文件的就绪类型，然后根据就绪类型执行操作

4. 服务端对消息进行处理

   1. 客户端发送一个消息，对应的sock就会处于读就绪状态，epoll将文件描述符返回，然后LoopOnce中对文件就绪类型进行判断
   2. 当sock文件处于读就绪时，调用recv方法（开始就绑定了），将客户端发来的数据进行接收
   3. 将读书读取到缓冲区_inbuffer中
   4. 读取完后对报文按照协议进行拆解（可以将请求封装成task，交给多线程执行）
   5. 拆解后进行处理，然后制作response，交给服务器
   6. 打开sock的写事件

5. 服务端向客户端发送消息

   调用sender方法发送消息

6. 客户端退出

#### 服务器的类结构

TcpServer、Connection、Epoll、Sock、Request、Response

#### 细节

1. _listensock监控着所有的链接请求，每当有新的链接， _listensock会处于读就绪，链接建立后会分配新的sock进行通信
2. 为了管理大量的链接，需要建立一个服务器链接映射表，这个表里面存着sock和conn对象，conn会绑定recv、send、except等回调方法
3. 

# 未完待续。。。











